<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Context-Generic Programming Guide (DRAFT)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Beginner Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="beginner/01-simple-greeter.html"><strong aria-hidden="true">2.1.</strong> Simple Greeter</a></li><li class="chapter-item expanded "><a href="beginner/02-generic-context.html"><strong aria-hidden="true">2.2.</strong> Generic Context</a></li><li class="chapter-item expanded "><a href="beginner/03-context-implementation.html"><strong aria-hidden="true">2.3.</strong> Context Implementation</a></li><li class="chapter-item expanded "><a href="beginner/04-greeter-component.html"><strong aria-hidden="true">2.4.</strong> Greeter Component</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Intermediate Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="intermediate/01-daytime-greeter.html"><strong aria-hidden="true">3.1.</strong> Daytime Greeter</a></li><li class="chapter-item expanded "><a href="intermediate/02-component-composition.html"><strong aria-hidden="true">3.2.</strong> Component Composition</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Advanced Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/01-person-querier.html"><strong aria-hidden="true">4.1.</strong> Person Querier</a></li><li class="chapter-item expanded "><a href="advanced/02-querier-consumer.html"><strong aria-hidden="true">4.2.</strong> Querier Consumer</a></li><li class="chapter-item expanded "><a href="advanced/03-store-impl.html"><strong aria-hidden="true">4.3.</strong> Store Implementation</a></li><li class="chapter-item expanded "><a href="advanced/04-caching-querier.html"><strong aria-hidden="true">4.4.</strong> Caching Querier</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Context-Generic Programming Guide (DRAFT)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>(todo)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-greeter"><a class="header" href="#simple-greeter">Simple Greeter</a></h1>
<p>Let's say we want to write a simple greeter program that greets a person.
The simplest way is to write a function like follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greet(name: String) {
    println!(&quot;Hello, {}!&quot;, name);
}
<span class="boring">}
</span></code></pre></pre>
<p>When calling the <code>greet</code> function from a larger context, we may want to pass
a <code>Person</code> struct with a <code>name</code> attribute on it, so that the caller does not
have to know how to get the person's name.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
    address: String,
    // ...
}

fn greet(person: &amp;Person) {
    println!(&quot;Hello, {}!&quot;, person.name);
}
<span class="boring">}
</span></code></pre></pre>
<p>But the caller of the <code>greet</code> function might not have the person's information
on hand, as it may be stored in a database. So we might want to implement
a <code>greet</code> function that accepts a <code>PersonId</code> and a database handler, so that
it can load the person's information from the database, and then greets them.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PersonId(String);
struct Person {
    id: PersonId,
    name: String,
    address: String,
    // ...
}

struct Database { /* ... */ }
struct DbError { /* ... */ }

impl Database {
    fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, DbError&gt; {
        unimplemented!() // stub
    }
}

fn greet(db: &amp;Database, person_id: &amp;PersonId) -&gt; Result&lt;(), DbError&gt; {
    let person = db.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>As the application grows, we can see that the complexity creeps in pretty
quickly even with such a simple example:</p>
<ul>
<li>The full details of the <code>Person</code> struct must be fetched regardless of
whether the <code>greet</code> function needs it.</li>
<li>The concrete implementation of <code>Database</code> is exposed to the greet function,
making it difficult to work with other databases.</li>
<li>The concrete error <code>DbError</code> from the database query is leaked into the
<code>greet</code> function implementation.</li>
</ul>
<p>When the application is still in its early stages, it might be tempting to
leave these concerns aside and not worry about them too much. But eventually,
we will reach a point where we need our application to work with different
implementations. For example:</p>
<ul>
<li>We may want a caching layer to cache the person's information instead of
querying directly from the database all the time.</li>
<li>We may want to have different database implementations, such as a mocked-up
database or an in-memory database.</li>
<li>We may want to have multiple concrete person types, so that the database
only fetches the essential information. e.g. <code>PersonWithName</code>,
<code>PersonWithFullDetails</code>, <code>PersonWithRoles</code> etc.</li>
</ul>
<h2 id="comparison-with-dynamic-typing"><a class="header" href="#comparison-with-dynamic-typing">Comparison with Dynamic Typing</a></h2>
<p>One thing worth noting with our <code>greet</code> example in Rust is that many of the
problems mentioned are applicable because we are programming in a statically-typed
language. If we were to re-implement the <code>greet</code> function in a dynamically-
typed language like JavaScript, many of these problems go away:</p>
<pre><code class="language-javascript">function greet(db, personId) {
    const person = db.queryPerson(personId)
    console.log(`Hello, ${person.name}!`)
}
</code></pre>
<p>Thanks to dynamic typing, the JavaScript <code>greet</code> function above is general
in several ways:</p>
<ul>
<li>The function can work with any <code>db</code> value, as long as it provides a valid
<code>query_person</code> method.</li>
<li>The function can work with any <code>person</code> value returned from <code>db.query_person</code>,
as long as it contains a <code>name</code> field that can be converted into a string.</li>
<li>The error can be thrown implicitly by <code>db.query_person</code> as an exception.</li>
</ul>
<p>On the upside, the dynamic nature of the <code>greet</code> function means that it can
easily be reused across multiple database and person implementations. On the
downside, since there is no type information, it is easy to accidentally call
<code>greet</code> with invalid implementations and only discover the errors late during
runtime execution.</p>
<p>Ideally, we would like to have the same benefits of writing generalized programs
in dynamically-typed contexts, but still enjoy the benefits of type checking when there are
mismatches in the specialized implementation.</p>
<h2 id="dynamic-context"><a class="header" href="#dynamic-context">Dynamic Context</a></h2>
<p>The first thing to notice when writing generalized functions is that there are
usually contextual values in the surrounding environment that are needed for
the program to execute successfully.</p>
<p>In our dynamic <code>greet</code> example, we can generalize the <code>db</code> value and think of it
as a <code>context</code> value, which may contain other environment parameters such as
what kind of greeting is used.</p>
<pre><code class="language-javascript">function greet(context, personId) {
    const person = context.queryPerson(personId)
    const greeting = context.getGreeting()
    console.log(`${greeting}, ${person.name}!`)
}
</code></pre>
<p>In the OOP world, the <code>context</code> value is typically referred to as a <code>this</code> or <code>self</code>
value. However, for clarity and for more structured composition, it is better
to think of it as a fully abstract value with unknown type. This allows the
context value to be augmented in a functional way, without having to resort to
using any OOP class hierarchy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-context"><a class="header" href="#generic-context">Generic Context</a></h1>
<p>There are ways that we can make our <code>greet</code> function in Rust works more flexibly
similar to its dynamic-typed counterparty. First, we define a concrete <code>Context</code>
type as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Database { /* ... */}
</span><span class="boring">struct DbError { /* ... */}
</span><span class="boring">impl Database {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, DbError&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>struct Context {
    database: Database,
    // ...
}

fn greet(context: &amp;Context, person_id: &amp;PersonId) -&gt; Result&lt;(), DbError&gt; {
    let person = context.database.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>At this stage, we have a concrete <code>Context</code> struct that contains the database
handle as well as other environment parameters that we may need. However,
<code>Context</code> is still concrete, so it is difficult to reuse the <code>greet</code> function
in a different context. So let's make the <code>Context</code> generic instead:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Database { /* ... */}
</span><span class="boring">struct DbError { /* ... */}
</span><span class="boring">
</span><span class="boring">impl Database {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, DbError&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>trait ContextWithDatabase {
    fn database(&amp;self) -&gt; &amp;Database;
}

fn greet&lt;Context&gt;(context: &amp;Context, person_id: &amp;PersonId) -&gt; Result&lt;(), DbError&gt;
where
    Context: ContextWithDatabase,
{
    let person = context.database().query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>In our first attempt, we turn <code>Context</code> into a generic type parameter.
With that, the concrete details of the context are lost, and we no longer
know how to access the fields such as the database. But we can recover that
by defining a <code>ContextWithDatabase</code> trait, which provides read-only
access to extract a reference to <code>Database</code> from the context.</p>
<p>With that, we are able to make <code>greet</code> work with any context type as
long as it contains a field for <code>Database</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Database { /* ... */}
</span><span class="boring">
</span><span class="boring">trait ContextWithDatabase {
</span><span class="boring">     fn database(&amp;self) -&gt; &amp;Database;
</span><span class="boring">}
</span><span class="boring">
</span>struct AppContext {
    database: Database
}

impl ContextWithDatabase for AppContext {
    fn database(&amp;self) -&gt; &amp;Database {
        &amp;self.database
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, since the <code>Database</code> type is concrete, it is challenging if we
want to run <code>greet</code> with an environment without a database, such as
an in-memory key-value store, cache store, or a blockchain. What we can do
instead is to define methods such that we can query for a person's details
directly from the context:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span>struct Error { /* ... */}

trait PersonQuerier {
    fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, Error&gt;;
}

fn greet&lt;Context&gt;(context: &amp;Context, person_id: &amp;PersonId)
    -&gt; Result&lt;(), Error&gt;
where
    Context: PersonQuerier,
{
    let person = context.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>We define a <code>PersonQuerier</code> trait that exposes a method for querying for a
person's details directly from the context. With that, we can have our <code>greet</code>
function work with any context type that knows how to query for person details,
regardless of whether it is implemented as a database query.</p>
<h2 id="context-with-error"><a class="header" href="#context-with-error">Context with Error</a></h2>
<p>One thing to note however is that the <code>Error</code> type in <code>PersonQuerier</code>
is concrete. With that, it would be problematic if we want to define new contexts
that have different query methods but also return different errors. While it
is possible to define a dynamic error type such as <code>Box&lt;dyn Error&gt;</code>, such type
erasure would mean that we lose information about what kinds of errors can happen
when we try to query for <code>Person</code> details.</p>
<p>We can instead make the error type <em>generic</em>. But instead of using it as a
generic parameter for <code>greet</code>, we can define it as an <em>associated type</em> for
the generic type <code>Context</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span>trait HasError {
    type Error;
}

trait PersonQuerier: HasError {
    fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, Self::Error&gt;;
}

fn greet&lt;Context&gt;(context: &amp;Context, person_id: &amp;PersonId) -&gt; Result&lt;(), Context::Error&gt;
where
    Context: PersonQuerier,
{
    let person = context.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>We define a new <code>HasError</code> trait with only one thing, which is the <code>Error</code>
associated type. Aside from that, there is nothing known about the <code>Error</code>
type, but that is ok as we will see later on. The trait <code>PersonQuerier</code>
then has <code>HasError</code> as its supertrait, esentially allowing it to access
the associated type as <code>Self::Error</code> in the return type of <code>query_person</code>.</p>
<p>We define the <code>Error</code> associated type in a separate <code>HasError</code> trait,
instead of directly in the <code>PersonQuerier</code> trait. As we will see later,
this is essential to allow multiple context traits to access the same
<code>Error</code> type.</p>
<p>In the <code>greet</code> function, we require the generic <code>Context</code> type to
implement <code>PersonQuerier</code>. But since <code>HasError</code> is a supertrait of
<code>PersonQuerier</code>, we would also able to access the error type as
<code>Context::Error</code>.</p>
<h2 id="explicit-associated-type-binding"><a class="header" href="#explicit-associated-type-binding">Explicit Associated Type Binding</a></h2>
<p>As we can see, by having generic type parameters as associated types in the
traits that <code>Context</code> implements, we are able to keep just one generic type
parameter in the <code>greet</code> function.</p>
<p>However, it is still possible for us to explicitly pull out <code>Error</code> as a generic
type parameter and bind to the <code>Error</code> associated type as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier: HasError {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;PersonId) -&gt;    Result&lt;Person, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>fn greet&lt;Context, Error&gt;(context: &amp;Context, person_id: &amp;PersonId)
    -&gt; Result&lt;(), Error&gt;
where
    Context: PersonQuerier&lt;Error=Error&gt;,
{
    let person = context.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>By specifying the trait bound <code>Context: PersonQuerier&lt;Error=Error&gt;</code>,
we state that the <code>greet</code> function works with any generic type <code>Error</code>,
provided that <code>Context::Error</code> is the same as <code>Error</code>. With the explicit
binding, we are able to have <code>greet</code> return <code>Result&lt;(), Error&gt;</code> instead of
<code>Result&lt;(), Context::Error&gt;</code>.</p>
<p>There are sometimes benefits when we bind the associated types to an explicit
generic type parameter. For one, the inferred type shown in IDEs like
Rust Analyzer would be simpler, as they are shown as <code>Error</code> instead of
the fully qualified syntax <code>&lt;Context as HasError&gt;::Error</code>.
As we will see later, explicit type parameters also help us by providing a
way to specify the additional trait bounds of the associated types.</p>
<p>Aside from that, it is up to the programmer to decide whether to bind
the associated types to explicit type parameters. The key thing to understand
here is that the explicit bindings are optional, and we can choose to
omit such parameters whenever it is appropriate.</p>
<h2 id="generic-person"><a class="header" href="#generic-person">Generic Person</a></h2>
<p>Right now, our <code>Error</code> type has become generic, but our <code>Person</code> type is
still concrete. We may also want to make the <code>Person</code> type generic in a
similar way, so that the <code>greet</code> function can work with any other
person types.</p>
<p>This may be essential for reasons such as performance. For instance,
depending on where <code>greet</code> is called, it may be desirable to load
all details about a person from the database so that it can be
cached, or conversely, it might be desirable to load minimal details in order to
save bandwidth.</p>
<p>From the perspective of <code>greet</code>, it does not matter what fields a <code>Person</code>
type has, as long as it can extract the name of the person as a string.
So we can generalize the <code>Person</code> type as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait NamedPerson {
    fn name(&amp;self) -&gt; &amp;str;
}

trait HasError {
    type Error;
}

trait PersonContext {
    type PersonId;
    type Person: NamedPerson;
}

trait PersonQuerier: PersonContext + HasError {
    fn query_person(
        &amp;self,
        person_id: &amp;Self::PersonId,
    ) -&gt; Result&lt;Self::Person, Self::Error&gt;;
}

fn greet&lt;Context&gt;(
    context: &amp;Context,
    person_id: &amp;Context::PersonId,
) -&gt; Result&lt;(), Context::Error&gt;
where
    Context: PersonQuerier,
{
    let person = context.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name());
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>We first define a <code>NamedPerson</code> trait, with a <code>name</code> method to extract a string
out from the person. We also define a <code>PersonContext</code> trait that has two
associated types: <code>PersonId</code> and <code>Person</code>. The <code>PersonId</code> type is completely
generic, as we don't care whether it is a string, an integer, or a UUID.
The associated type <code>Person</code> is also generic, but we also add a trait bound
that the type must implement <code>NamedPerson</code>.</p>
<p>The <code>PersonQuerier</code> is now defined with <code>PersonContext</code> as another of its
supertraits. With that, the <code>query_person</code> method becomes completely abstract.
A generic consumer would only know that, given an abstract type
<code>Context::PersonId</code>, it can query the <code>Context</code> and either get back an abstract
type <code>Context::Person</code> that implements <code>NamedPerson</code>, or get back an abstract
error <code>Context::Error</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-implementation"><a class="header" href="#context-implementation">Context Implementation</a></h1>
<p>With the basic traits implemented, we now look at how we can define a
concrete context that satisfies the traits:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>struct BasicPerson {
    name: String,
}

impl NamedPerson for BasicPerson {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}

struct AppContext {
    database: Database,
}

// Database stubs
struct Database;
struct DbError;

enum AppError {
    Database(DbError),
    // ...
}

impl HasError for AppContext {
    type Error = AppError;
}

impl PersonContext for AppContext {
    type PersonId = String;
    type Person = BasicPerson;
}

impl PersonQuerier for AppContext {
    fn query_person(&amp;self, person_id: &amp;Self::PersonId)
        -&gt; Result&lt;Self::Person, Self::Error&gt;
    {
        unimplemented!() // database stub
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We first define a <code>BasicPerson</code> struct with only a <code>name</code> field,
since that is the minimal information required for <code>greet</code> to work.
We implement <code>NamedPerson</code> for <code>BasicPerson</code>, by simply returning
<code>&amp;self.name</code>.</p>
<p>We also define an <code>AppContext</code> struct with a stub database field.
For demonstration purposes, we have a dummy <code>Database</code> struct, and a <code>DbError</code>
type to represent database errors. We also define an <code>AppError</code>
enum to represent all application errors, with one of them being
<code>DbError</code>.</p>
<p>We implement <code>HasError</code> for <code>AppContext</code>, with <code>AppError</code> as
the <code>Error</code> type. We also implement <code>PersonContext</code> for <code>AppContext</code>,
with the <code>PersonId</code> associated type being <code>String</code> and the <code>Person</code>
associated type being <code>BasicPerson</code>. We also implement <code>PersonQuerier</code>
but leave the <code>query_person</code> as a stub for performing database queries
in an actual application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="greeter-component"><a class="header" href="#greeter-component">Greeter Component</a></h1>
<p>The <code>greet</code> function that we have defined at this point can now work with
any context type that implements the required traits. In practice, we may
also want to implement different versions of the <code>greet</code> function so that
they can be consumed generically by other components.</p>
<p>With the generic context design, we define a <code>Greeter</code> interface that
is parameterized by a generic context, and can be used by any other
components that also share the same context. This can be defined as
follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait Greeter&lt;Context&gt;
where
    Context: PersonContext + HasError,
{
    fn greet(
        &amp;self,
        context: &amp;Context,
        person_id: &amp;Context::PersonId,
    ) -&gt; Result&lt;(), Context::Error&gt;;
}

struct SimpleGreeter;

impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
where
    Context: PersonQuerier,
{
    fn greet(
        &amp;self,
        context: &amp;Context,
        person_id: &amp;Context::PersonId,
    ) -&gt; Result&lt;(), Context::Error&gt;
    {
        let person = context.query_person(person_id)?;
        println!(&quot;Hello, {}&quot;, person.name());
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Greeter</code> trait is defined to be parameterized by a generic <code>Context</code> type,
which is required to implement both <code>PersonContext</code> and <code>HasError</code>.
The <code>greet</code> method is then defined without generic parameters, as these have been
captured in the trait definition. We then define an empty struct <code>SimpleGreeter</code>,
which is there only to implement the <code>Greeter</code> trait for any <code>Context</code> type
that implements <code>PersonQuerier</code>.</p>
<p>It is worth noticing here that in the main <code>Greeter</code> trait definition,
the <code>Context</code> type, is only required to implement <code>PersonContext</code> and
<code>HasError</code>, but there is no mention of the <code>PersonQuerier</code>
trait bound. On the other hand, the concrete <code>Greeter</code> implementation
for <code>SimpleGreeter</code> can require the additional trait bound
<code>Context: PersonQuerier</code> in its <code>impl</code> definition.</p>
<p>This demonstrates the benefits of separating the <code>PersonQuerier</code>
from the <code>PersonContext</code> trait: From the perspective of a consumer
that uses the <code>Greeter</code> component, it does not need to know whether
the generic context type implements <code>PersonQuerier</code>. This means
that from the trait bounds alone, we can tell whether a piece of code
can call <code>query_person</code> directly, or whether it can only call the
<code>greet</code> method to greet a person without knowing how the greeter determined
the person's name.</p>
<h2 id="greeter-instance"><a class="header" href="#greeter-instance">Greeter Instance</a></h2>
<p>In the previous chapter, we defined <code>AppContext</code> as a concrete implementation
for the context traits <code>HasError</code>, <code>PersonContext</code>, and <code>PersonQuerier</code>.
Based on the earlier definition of <code>SimpleGreeter</code> and its <code>Greeter</code>
implementation, we can deduce that <code>SimpleGreeter</code> should implement
<code>Greeter&lt;AppContext&gt;</code>.</p>
<p>But how can we ensure that we implemented <code>AppContext</code> correctly to be used by
<code>SimpleGreeter</code>? If we forgot to implement any dependency that is required by
<code>SimpleGreeter</code>, such as <code>PersonQuerier</code>, we would get a compile-time error
when trying to use <code>SimpleGreeter</code> as <code>Greeter&lt;AppContext&gt;</code>. Worse, if we try
to use <code>SimpleGreeter</code> within another generic component, the error messages
may become too incomprehensible to find out what went wrong.</p>
<p>In test-driven development, it is common practice that we would write <em>tests</em>
that check that our code satisfies certain requirements and constraints.
Following the same principle, we would want to write tests that check that
<code>SimpleGreeter</code> does implements <code>Greeter&lt;AppContext&gt;</code>. But instead of writing
<em>dynamic tests</em> that checks for the program behavior at runtime, we can write
<em>static tests</em> that checks that the program requirements are satisfied at
<em>compile time</em>.</p>
<p>Our test would be implemented as an <code>app_greeter</code> function which checks at
<em>compile time</em> that <code>SimpleGreeter</code> implements <code>Greeter&lt;AppContext&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleGreeter;
</span><span class="boring">
</span><span class="boring">impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
</span><span class="boring">where
</span><span class="boring">     Context: PersonQuerier,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let person = context.query_person(person_id)?;
</span><span class="boring">         println!(&quot;Hello, {}&quot;, person.name());
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">struct BasicPerson {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl NamedPerson for BasicPerson {
</span><span class="boring">    fn name(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct AppContext {
</span><span class="boring">    database: Database,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Database stubs
</span><span class="boring">struct Database;
</span><span class="boring">struct DbError;
</span><span class="boring">
</span><span class="boring">enum AppError {
</span><span class="boring">    Database(DbError),
</span><span class="boring">    // ...
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl HasError for AppContext {
</span><span class="boring">    type Error = AppError;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PersonContext for AppContext {
</span><span class="boring">    type PersonId = String;
</span><span class="boring">    type Person = BasicPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PersonQuerier for AppContext {
</span><span class="boring">    fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">        -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">    {
</span><span class="boring">        unimplemented!() // database stub
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn app_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
    SimpleGreeter
}
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>app_greeter</code> function accepts nothing and returns <code>impl Greeter&lt;AppContext&gt;</code>.
This indicates that the function can return a value with an <em>existential type</em>
that implements <code>Greeter&lt;AppContext&gt;</code>. Inside the function body, we simply
return a <code>SimpleGreeter</code> value. From the surface, it may look like this
is effectively the same as the function with signature
<code>fn app_greeter() -&gt; SimpleGreeter</code>. But by returning <code>impl Greeter&lt;AppContext&gt;</code>,
we force the Rust compiler to check here that <code>SimpleGreeter</code> must
implement <code>Greeter&lt;AppContext&gt;</code>.</p>
<p>Having <code>app_greeter</code> compiled successfully is sufficient to prove that
<code>SimpleGreeter</code> can <em>always</em> be used as a <code>Greeter&lt;AppContext&gt;</code>. Hence, we can
say that <code>app_greeter</code> is a <em>proof</em> that <code>SimpleGreeter: Greeter&lt;AppContext&gt;</code>.</p>
<p>We call static tests like <code>app_greeter</code> as proofs, as it works similar to
writing mathematical proofs as programs in <em>dependent-typed programming</em>.
In this style of programming,the type-checking of a program alone is sufficient
to prove that a given requirement is <em>always</em> satisfied, without us having to
<em>execute</em> the program.
This is much more efficient as compared to dynamic checking, which can only
check for requirements at runtime and raise errors when the requirements
are not satisfied.</p>
<h2 id="compile-time-dependency-injection"><a class="header" href="#compile-time-dependency-injection">Compile-Time Dependency Injection</a></h2>
<p>The <code>app_greeter</code> function demonstrates a form of <em>dependency injection</em>
done at compile time. This is because for any code to use a type implementing
<code>Greeter&lt;Context&gt;</code>, they only need to know that <code>Context</code> implements
<code>HasError</code> and <code>PersonContext</code>. But to make <code>SimpleGreeter</code> implement
<code>Greeter&lt;Context&gt;</code>, it also needs <code>Context</code> to implement <code>PersonQuerier</code>.</p>
<p>When we return <code>SimpleGreeter</code> inside <code>app_greeter</code>, the Rust compiler
figures out that <code>SimpleGreeter</code> requires <code>AppContext</code> to implement
<code>PersonQuerier</code>. It would then try to automatically <em>resolve</em> the
dependency by searching for an implementation of <code>PersonQuerier</code>
for <code>AppContext</code>. Upon finding the implementation, Rust &quot;binds&quot; that
implementation with <code>SimpleGreeter</code> and returns it as an existential
type that implements <code>Greeter&lt;AppContext&gt;</code>. As a result,
we can treat the type returned from <code>app_greeter</code> as an abstract type,
and &quot;forget&quot; the fact that <code>AppContext</code> implements <code>PersonQuerier</code>.</p>
<p>This pattern of making use of Rust's trait system for dependency injection
efficiently solves the
<a href="https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/">context and capabilities problem</a>
in Rust. Without it, we would have to rely on more exotic language features
that are not available in Rust, or resort to manually passing dependencies
around by hand.</p>
<p>For example, we could perform manual binding for an implementation similar
to <code>SimpleGreeter</code> as a purely generic function as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span>fn make_simpler_greeter&lt;Context, PersonId, Person, Error&gt;(
    query_person: impl Fn(&amp;Context, &amp;PersonId) -&gt; Result&lt;Person, Error&gt;,
) -&gt; impl Fn(&amp;Context, &amp;PersonId) -&gt; Result&lt;(), Error&gt;
where
    Person: NamedPerson,
{
    move | context, person_id | {
        let person = query_person(context, person_id)?;
        println!(&quot;Hello, {}&quot;, person.name());
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As we can see, the ad hoc function <code>make_simpler_greeter</code> that we defined is
much more verbose than the earlier trait-based implementation. We would
have to explicitly track 4 generic type parameters, and we would have to
manually pass in dependencies like <code>query_person</code> and return nested closures.</p>
<p>When we delegate the management of the context dependencies to Rust's trait
system, the Rust compiler handles the binding of dependencies automatically in
a manner similar to what is being done in the example above. The binding process
is not only automated, the code that the compiler generates is also much more
efficient. Because the binding is done at compile time, the Rust compiler is
able to perform many further optimizations, such as code inlining.</p>
<p>As we will see later, this process of automatic resolution can be applied to
<em>nested</em> dependencies. Thanks to how the trait system works, we can specify
complex dependencies for our components and have the Rust compiler figure out
how to stitch together the dependencies and construct the combined components
that we need.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="daytime-greeter"><a class="header" href="#daytime-greeter">Daytime Greeter</a></h1>
<p>Now suppose that we want to extend our greeter component such that it only
greets a person at day time during office hours. We could directly modify
the <code>Greeter</code> implementation for <code>SimpleGreeter</code> to do that, but that may
complicate the implementation and makes it more difficult to understand
the core logic. Alternatively, we could define a new <code>DaytimeGreeter</code>
component that <em>wraps</em> around the original <code>SimpleGreeter</code>.</p>
<p>This new <code>DaytimeGreeter</code> component would need to know how to
get the current time of the system, as well as how to tell whether
a given time value is at daytime. Following the context pattern we
learned, we will also define a <code>HasTime</code> trait for getting the time:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SimpleTime {
    fn is_daytime(&amp;self) -&gt; bool;
}

trait HasTime {
    type Time;

    fn now(&amp;self) -&gt; Self::Time;
}
<span class="boring">}
</span></code></pre></pre>
<p>For demonstration purposes, we first define a <code>SimpleTime</code> trait that provides an
<code>is_daytime</code> method to tell whether the current time value is considered daytime.
Following that, we define a <code>HasTime</code> trait that provides a <code>now</code> method
to fetch the current time from the context. Notice that the associated type
<code>Time</code> does <em>not</em> implement <code>SimpleTime</code>. This is so that we can learn how
to inject the <code>SimpleTime</code> constraint as an <em>indirect dependency</em> using the
same dependency injection technique.</p>
<p>We then define the <code>DaytimeGreeter</code> component as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait SimpleTime {
</span><span class="boring">    fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasTime {
</span><span class="boring">    type Time;
</span><span class="boring">
</span><span class="boring">    fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">    Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">    fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">        -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>struct DaytimeGreeter&lt;InGreeter&gt;(InGreeter);

impl&lt;Context, InGreeter&gt; Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
where
    InGreeter: Greeter&lt;Context&gt;,
    Context: HasTime + PersonContext + HasError,
    Context::Time: SimpleTime,
{
    fn greet(
        &amp;self,
        context: &amp;Context,
        person_id: &amp;Context::PersonId,
    ) -&gt; Result&lt;(), Context::Error&gt;
    {
        let now = context.now();
        if now.is_daytime() {
            self.0.greet(context, person_id)?;
        } else {
            println!(&quot;Sorry, the shop has closed now!&quot;);
        }
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We define the <code>DaytimeGreeter</code> with an <code>InGreeter</code> type parameter, which
would act as the inner <code>Greeter</code> component. We then define a generic
implementation of <code>Greeter&lt;Context&gt;</code> for <code>DaytimeGreeter&lt;InGreeter&gt;</code>.
In the trait bounds, we require the inner greeter <code>InGreeter</code> to also
implement <code>Greeter&lt;Context&gt;</code>, since the core logic is implemented over there.</p>
<p>Aside from <code>PersonContext</code> and <code>HasError</code>, we also require <code>Context</code>
to implement <code>HasTime</code> for <code>DaytimeGreeter</code> to fetch the current time.
Other than that, we also explicitly require that the associated type
<code>Context::Time</code> implements <code>SimpleTime</code>.</p>
<p>By specifying <code>SimpleTime</code> as an explicit dependency, we relax the requirement
of how the <code>HasTime</code> trait can be used by other components. So if
<code>SimpleTime</code> is only ever used by <code>DaytimeGreeter</code>, and if an application
does not need <code>DaytimeGreeter</code>, then a concrete context can skip implementing
<code>SimpleTime</code> for its time type, even if the trait <code>HasTime</code> is used by
other components.</p>
<h2 id="error-injection"><a class="header" href="#error-injection">Error Injection</a></h2>
<p>In our earlier implementation of <code>DaytimeGreeter</code>, the greeter simply prints
out that the shop has closed, and then returns successfully without calling
the inner greeter. But what if we want <code>DaytimeGreeter</code> to return an error
during night time? Since the associated type <code>Error</code> in <code>HasError</code>
is abstract, there is no obvious way we can construct an error value of
type <code>Error</code>.</p>
<p>On the other hand, we learned in the previous section that we can specify an
additional trait bound that <code>Context::Time</code> implements <code>SimpleTime</code>.
Similarly, we can also specify additional trait bounds for <code>Context::Error</code>
so that we gain additional knowledge of how to construct an error value.</p>
<p>We can do this by defining a custom <code>ShopClosedError</code> struct and require that
<code>Context::Error</code> implement a <code>From</code> instance for conversion from <code>ShopClosedError</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait SimpleTime {
</span><span class="boring">     fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">     fn duration_since(&amp;self, other: &amp;Self) -&gt; Duration;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasTime {
</span><span class="boring">     type Time;
</span><span class="boring">
</span><span class="boring">     fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>struct ShopClosedError&lt;Time&gt; { time: Time }

struct DaytimeGreeter&lt;InGreeter&gt;(InGreeter);

impl&lt;Context, InGreeter&gt; Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
where
    InGreeter: Greeter&lt;Context&gt;,
    Context: HasTime + PersonContext + HasError,
    Context::Time: SimpleTime,
    Context::Error: From&lt;ShopClosedError&lt;Context::Time&gt;&gt;,
{
    fn greet(
        &amp;self,
        context: &amp;Context,
        person_id: &amp;Context::PersonId,
    ) -&gt; Result&lt;(), Context::Error&gt;
    {
        let now = context.now();
        if now.is_daytime() {
            self.0.greet(context, person_id)
        } else {
            Err(ShopClosedError { time: now }.into())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>ShopClosedError</code> is parameterized by a generic <code>Time</code> type so that
it can provide details about the time that caused <code>ShopClosedError</code> to be
raised. In the <code>Greeter</code> implementation for <code>DaytimeGreeter</code> we add an
additional trait bound to require <code>Context::Error</code> to implement
<code>From&lt;ShopClosedError&lt;Context::Time&gt;&gt;</code>. With that, if the time returned
by <code>context.now()</code> is not considered daytime, we can construct a
<code>ShopClosedError</code> and turn it into <code>Context::Error</code> using the <code>into</code> method.</p>
<p>What we have done above is essentially specifying an <em>error injection method</em>
for injecting a sub-error type into the main error type. With this, individual
components do not need to know about the concrete application error and all
the possible errors that can be raised. But they can still <em>inject</em> specific
errors into the main error type by requiring additional <code>From</code> constraints.</p>
<p>For instance, <code>DaytimeGreeter</code> does not need to be aware of whether the inner
greeter component would raise a database error. From the <code>impl</code> definition,
we can be confident that <code>DaytimeGreeter</code> itself cannot raise any sub-error
other than <code>ShopClosedError</code>.</p>
<h2 id="multiple-type-bindings"><a class="header" href="#multiple-type-bindings">Multiple Type Bindings</a></h2>
<p>When specifying the constraints for indirect dependencies, we have to keep using
the <code>Context::</code> prefix to access associated types like <code>Context::Error</code>. Worse,
once we start using nested associated types, we have to resort to using fully
qualified syntax like <code>&lt;Context::Foo as Foo&gt;::Bar</code>; <code>Context::Foo::Bar</code> doesn't work.</p>
<p>To help simplify the trait bounds for components like <code>DaytimeGreeter</code>, we
can use the explicit associated type bindings we learned about earlier:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait SimpleTime {
</span><span class="boring">     fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">     fn duration_since(&amp;self, other: &amp;Self) -&gt; Duration;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasTime {
</span><span class="boring">     type Time;
</span><span class="boring">
</span><span class="boring">     fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct ShopClosedError&lt;Time&gt; { time: Time }
</span><span class="boring">
</span><span class="boring">struct DaytimeGreeter&lt;InGreeter&gt;(InGreeter);
</span><span class="boring">
</span>impl&lt;Context, InGreeter, Time, Error, PersonId&gt;
    Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
where
    InGreeter: Greeter&lt;Context&gt;,
    Context: HasError&lt;Error=Error&gt;,
    Context: PersonContext&lt;PersonId=PersonId&gt;,
    Context: HasTime&lt;Time=Time&gt;,
    Time: SimpleTime,
    Error: From&lt;ShopClosedError&lt;Time&gt;&gt;,
{
    fn greet(&amp;self, context: &amp;Context, person_id: &amp;PersonId)
        -&gt; Result&lt;(), Error&gt;
    {
        let now = context.now();
        if now.is_daytime() {
            self.0.greet(context, person_id)
        } else {
            Err(ShopClosedError { time: now }.into())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In our new <code>Greeter</code> implementation, we introduce the generic parameters
<code>Time</code>, <code>Error</code>, and <code>PersonId</code>. We then bind the types to the associated
types of the context traits, such as <code>HasError&lt;Error=Error&gt;</code>. With the
bindings in place we can have simpler trait bounds like <code>Time: SimpleTime</code>
to be specified in place of the more verbose <code>Context::Time: SimpleTime</code>.</p>
<h2 id="dynamic-typed-interpretation"><a class="header" href="#dynamic-typed-interpretation">Dynamic-Typed Interpretation</a></h2>
<pre><code class="language-javascript">function daytime_greeter(in_greeter) {
    return function(context, person_id) {
        const now = context.now()
        if now.is_daytime() {
            return in_greeter.greet(context, person_id)
        } else {
            throw new ShopeClosedError({ time: now })
        }
    }
}
</code></pre>
<pre><code class="language-javascript">function build_daytime_greeter_class(deps) {
    return Class {
        constructor(in_greeter) {
            this.in_greeter = in_greeter
        }

        greet(context, person_id) {
            const now = deps.HasTime.prototype.now.call(context)
            if deps.HasTime.Time.prototype.is_daytime.call(now) {
                return deps.InGreeter.prototype.greet.call(
                    this.in_greeter, context, person_id)
            } else {
                throw deps.HasError.Error.from(
                    new ShopeClosedError({ time: now }))
            }
        }
    }
}
</code></pre>
<pre><code class="language-javascript">const DaytimeGreeter = build_daytime_greeter_class({
    InGreeter: ...,
    HasError: {
        Error: {
            from: function(err) { ... }
        },
    },
    PersonContext: {
        PersonId: ...,
        Person: ...,
    },
    HasTime: {
        Time: {
            prototype: {
                is_daytime: function() { ... }
            }
        }
    },
})
</code></pre>
<pre><code class="language-javascript">function build_daytime_greeter_class(deps) {
    const {
        HasTime,
        HasError,
        InGreeter,
    } = deps

    const { Time } = HasTime
    const { Error } = HasError

    return Class {
        constructor(in_greeter) {
            this.in_greeter = in_greeter
        }

        greet(context, person_id) {
            const now = HasTime.prototype.now.call(context)

            if Time.prototype.is_daytime.call(now) {
                return InGreeter.prototype.greet.call(
                    this.in_greeter, context, person_id)
            } else {
                throw Error.from(
                    new ShopeClosedError({ time: now }))
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-composition"><a class="header" href="#component-composition">Component Composition</a></h1>
<p>Now that we have both <code>SimpleGreeter</code> and <code>DaytimeGreeter</code> implemented, we
can look at how we can define a full application context that satisfies the
constraints of both greeters. To better structure our application, we also
separate out different parts of the code into separate modules.</p>
<p>First, we put all the abstract traits into a <code>traits</code> module:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    mod traits {
        pub trait NamedPerson {
            fn name(&amp;self) -&gt; &amp;str;
        }

        pub trait SimpleTime {
            fn is_daytime(&amp;self) -&gt; bool;
        }

        pub trait HasError {
            type Error;
        }

        pub trait PersonContext {
            type PersonId;
            type Person: NamedPerson;
        }

        pub trait HasTime {
            type Time;

            fn now(&amp;self) -&gt; Self::Time;
        }
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This module does not contain any concrete type definitions, and thus has minimal
dependencies on external crates.</p>
<p>In practice, the trait definitions can be placed in different sub-modules so
that we can have more fine grained control over which traits a component depends
on.</p>
<p>Next, we define <code>SimpleGreeter</code> and <code>DaytimeGreeter</code> in separate modules.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    mod traits {
        // ...
<span class="boring">        pub trait NamedPerson {
</span><span class="boring">            fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait SimpleTime {
</span><span class="boring">            fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasError {
</span><span class="boring">            type Error;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonContext {
</span><span class="boring">            type PersonId;
</span><span class="boring">            type Person: NamedPerson;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasTime {
</span><span class="boring">            type Time;
</span><span class="boring">
</span><span class="boring">            fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">                -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait Greeter&lt;Context&gt;
</span><span class="boring">        where
</span><span class="boring">            Context: PersonContext + HasError,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">        }
</span>    }

    mod simple_greeter {
        use super::traits::{Greeter, NamedPerson, PersonQuerier};

        pub struct SimpleGreeter;

        impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
        where
            Context: PersonQuerier,
        {
            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
                -&gt; Result&lt;(), Context::Error&gt;
            {
                let person = context.query_person(person_id)?;
                println!(&quot;Hello, {}&quot;, person.name());
                Ok(())
            }
        }
    }

    mod daytime_greeter {
        use super::traits::{
            Greeter, HasError, PersonContext,
            HasTime, SimpleTime,
        };

        pub struct DaytimeGreeter&lt;InGreeter&gt;(pub InGreeter);

        pub struct ShopClosedError&lt;Time&gt; { time: Time }

        impl&lt;Context, InGreeter, Time, Error, PersonId&gt;
            Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
        where
            InGreeter: Greeter&lt;Context&gt;,
            Context: HasError&lt;Error=Error&gt;,
            Context: PersonContext&lt;PersonId=PersonId&gt;,
            Context: HasTime&lt;Time=Time&gt;,
            Time: SimpleTime,
            Error: From&lt;ShopClosedError&lt;Time&gt;&gt;,
        {
            fn greet(&amp;self, context: &amp;Context, person_id: &amp;PersonId)
                -&gt; Result&lt;(), Error&gt;
            {
                let now = context.now();
                if now.is_daytime() {
                    self.0.greet(context, person_id)
                } else {
                    Err(ShopClosedError { time: now }.into())
                }
            }
        }
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The two greeter components do not depend on each other, but they all depend
on the <code>traits</code> crate to make use of the abstract definitions. Since these
components do not depend on other crates, they are also <em>abstract</em> components
that can be instantiated with <em>any</em> context types that satisfy the trait
bounds.</p>
<p>Next, we define our concrete <code>AppContext</code> struct that implements all
context traits:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    mod traits {
        // ...
<span class="boring">        pub trait NamedPerson {
</span><span class="boring">            fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait SimpleTime {
</span><span class="boring">            fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasError {
</span><span class="boring">            type Error;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonContext {
</span><span class="boring">            type PersonId;
</span><span class="boring">            type Person: NamedPerson;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasTime {
</span><span class="boring">            type Time;
</span><span class="boring">
</span><span class="boring">            fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">                -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait Greeter&lt;Context&gt;
</span><span class="boring">        where
</span><span class="boring">            Context: PersonContext + HasError,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">        }
</span>    }

    mod simple_greeter {
        // ...
    }

    mod daytime_greeter {
        pub struct ShopClosedError&lt;Time&gt; { time: Time }
        // ...
    }

    mod context {
        use super::traits::*;
        use super::daytime_greeter::ShopClosedError;

        #[derive(Copy, Clone, PartialEq, Eq)]
        pub enum DummyTime {
            DayTime,
            NightTime,
        }

        pub struct BasicPerson {
            name: String,
        }

        pub struct AppContext {
            database: Database,
            time: DummyTime,
        }

        // Database stubs
        struct Database;
        struct DbError;

        pub enum AppError {
            Database(DbError),
            ShopClosed(ShopClosedError&lt;DummyTime&gt;),
            // ...
        }

        impl HasError for AppContext {
            type Error = AppError;
        }

        impl PersonContext for AppContext {
            type PersonId = String;
            type Person = BasicPerson;
        }

        impl HasTime for AppContext {
            type Time = DummyTime;

            fn now(&amp;self) -&gt; DummyTime {
                self.time
            }
        }

        impl PersonQuerier for AppContext {
            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
                -&gt; Result&lt;Self::Person, Self::Error&gt;
            {
                unimplemented!() // database stub
            }
        }

        impl NamedPerson for BasicPerson {
            fn name(&amp;self) -&gt; &amp;str {
                &amp;self.name
            }
        }

        impl SimpleTime for DummyTime {
            fn is_daytime(&amp;self) -&gt; bool {
                self == &amp;DummyTime::DayTime
            }
        }

        impl From&lt;ShopClosedError&lt;DummyTime&gt;&gt; for AppError {
            fn from(err: ShopClosedError&lt;DummyTime&gt;) -&gt; Self {
                Self::ShopClosed(err)
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Compared to before, we define a <code>DummyTime</code> struct that
mocks the current time with either day time or night time. We then
implement <code>HasTime</code> for <code>AppContext</code>, with <code>DummyTime</code> being the
<code>Time</code> type. We also add <code>ShopClosedError&lt;DummyTime&gt;</code> as a variant to
<code>AppError</code> and define a <code>From</code> instance for it.</p>
<p>As we can see in this exercise, by having all types used by the greeter
components as abstract types, it becomes very easy to mock up dependencies
such as time functionality without having to commit to a specific time library.
The explicit dependencies also help us better understand what features are
really needed from the concrete types. If we know that our application only needs
the <code>SimpleTime</code> trait, then there are more options out there that we can
try out and we can easily swap between them.</p>
<p>It is also worth noting that it doesn't matter whether the concrete types
<code>AppContext</code> and <code>BasicPerson</code> have private or public fields.
Since the components do not have access to the concrete types, all concrete
fields are essentially private and can only be exposed via trait methods.</p>
<p>Finally, we define an <code>instances</code> module to encapsulate the witness of
satisfying all dependencies required from <code>AppContext</code> to implement
the <code>Greeter</code> components:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    mod traits {
        // ...
<span class="boring">        pub trait NamedPerson {
</span><span class="boring">            fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait SimpleTime {
</span><span class="boring">            fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasError {
</span><span class="boring">            type Error;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonContext {
</span><span class="boring">            type PersonId;
</span><span class="boring">            type Person: NamedPerson;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasTime {
</span><span class="boring">            type Time;
</span><span class="boring">
</span><span class="boring">            fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">                -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait Greeter&lt;Context&gt;
</span><span class="boring">        where
</span><span class="boring">            Context: PersonContext + HasError,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">        }
</span>    }

    mod simple_greeter {
        // ...
<span class="boring">        use super::traits::{Greeter, NamedPerson, PersonQuerier};
</span><span class="boring">
</span><span class="boring">        pub struct SimpleGreeter;
</span><span class="boring">
</span><span class="boring">        impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
</span><span class="boring">        where
</span><span class="boring">            Context: PersonQuerier,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Context::Error&gt;
</span><span class="boring">            {
</span><span class="boring">                let person = context.query_person(person_id)?;
</span><span class="boring">                println!(&quot;Hello, {}&quot;, person.name());
</span><span class="boring">                Ok(())
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }

    mod daytime_greeter {
        // ...
<span class="boring">        use super::traits::{
</span><span class="boring">            Greeter, HasError, PersonContext,
</span><span class="boring">            HasTime, SimpleTime,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        pub struct DaytimeGreeter&lt;InGreeter&gt;(pub InGreeter);
</span><span class="boring">
</span><span class="boring">        pub struct ShopClosedError&lt;Time&gt; { time: Time }
</span><span class="boring">
</span><span class="boring">        impl&lt;Context, InGreeter, Time, Error, PersonId&gt;
</span><span class="boring">            Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
</span><span class="boring">        where
</span><span class="boring">            InGreeter: Greeter&lt;Context&gt;,
</span><span class="boring">            Context: HasError&lt;Error=Error&gt;,
</span><span class="boring">            Context: PersonContext&lt;PersonId=PersonId&gt;,
</span><span class="boring">            Context: HasTime&lt;Time=Time&gt;,
</span><span class="boring">            Time: SimpleTime,
</span><span class="boring">            Error: From&lt;ShopClosedError&lt;Time&gt;&gt;,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Error&gt;
</span><span class="boring">            {
</span><span class="boring">                let now = context.now();
</span><span class="boring">                if now.is_daytime() {
</span><span class="boring">                    self.0.greet(context, person_id)
</span><span class="boring">                } else {
</span><span class="boring">                    Err(ShopClosedError { time: now }.into())
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }

    mod context {
        // ...
<span class="boring">        use super::traits::*;
</span><span class="boring">        use super::daytime_greeter::ShopClosedError;
</span><span class="boring">
</span><span class="boring">        #[derive(Copy, Clone, PartialEq, Eq)]
</span><span class="boring">        pub enum DummyTime {
</span><span class="boring">            DayTime,
</span><span class="boring">            NightTime,
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub struct BasicPerson {
</span><span class="boring">            name: String,
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub struct AppContext {
</span><span class="boring">            database: Database,
</span><span class="boring">            time: DummyTime,
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Database stubs
</span><span class="boring">        struct Database;
</span><span class="boring">        struct DbError;
</span><span class="boring">
</span><span class="boring">        pub enum AppError {
</span><span class="boring">            Database(DbError),
</span><span class="boring">            ShopClosed(ShopClosedError&lt;DummyTime&gt;),
</span><span class="boring">            // ...
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl HasError for AppContext {
</span><span class="boring">            type Error = AppError;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl PersonContext for AppContext {
</span><span class="boring">            type PersonId = String;
</span><span class="boring">            type Person = BasicPerson;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl HasTime for AppContext {
</span><span class="boring">            type Time = DummyTime;
</span><span class="boring">
</span><span class="boring">            fn now(&amp;self) -&gt; DummyTime {
</span><span class="boring">                self.time
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl PersonQuerier for AppContext {
</span><span class="boring">            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">                -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">            {
</span><span class="boring">                unimplemented!() // database stub
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl NamedPerson for BasicPerson {
</span><span class="boring">            fn name(&amp;self) -&gt; &amp;str {
</span><span class="boring">                &amp;self.name
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl SimpleTime for DummyTime {
</span><span class="boring">            fn is_daytime(&amp;self) -&gt; bool {
</span><span class="boring">                self == &amp;DummyTime::DayTime
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl From&lt;ShopClosedError&lt;DummyTime&gt;&gt; for AppError {
</span><span class="boring">            fn from(err: ShopClosedError&lt;DummyTime&gt;) -&gt; Self {
</span><span class="boring">                Self::ShopClosed(err)
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }

    mod instances {
        use super::traits::Greeter;
        use super::context::AppContext;
        use super::simple_greeter::SimpleGreeter;
        use super::daytime_greeter::DaytimeGreeter;

        pub fn base_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
            SimpleGreeter
        }

        pub fn app_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
            DaytimeGreeter(base_greeter())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We first have a <code>base_greeter</code> function which witnesses that <code>SimpleGreeter</code>
implements <code>Greeter&lt;AppContext&gt;</code>. We then define an <code>app_greeter</code> function
which witnesses that <code>DaytimeGreeter&lt;SimpleGreeter&gt;</code> <em>also</em> implements
<code>Greeter&lt;AppContext&gt;</code>.</p>
<p>Notice that in the <code>app_greeter</code> body, we construct the greeter with
<code>DaytimeGreeter(base_greeter())</code> instead of <code>DaytimeGreeter(SimpleGreeter)</code>.
In theory, both expressions are valid and have the same effect, but calling
<code>base_greeter</code> inside <code>app_greeter</code> implies that <code>app_greeter</code> does not care
what the concrete type of <code>base_greeter</code> is; all that matters is that it
implements <code>Greeter&lt;AppContext&gt;</code>.</p>
<p>Having separate witness functions can also help us debug any errors that arise
in dependencies much more easily. Let's say that we forgot to implement
<code>PersonQuerier</code> for <code>AppContext</code> such that the dependency for
<code>SimpleGreeter</code> would not be satisfied; we would get a type error in
<code>base_greeter</code>. However, no errors would crop up in <code>app_greeter</code>,
because it doesn't care that base greeter implements <code>SimpleGreeter</code>.</p>
<p>If we were to write the complex expression in one go, like
<code>DaytimeGreeter(SimpleGreeter)</code>, it would be less clear which part of the
expression caused the type error. Things would get worse if we introduced more
complex component composition. Therefore, it is always a good practice to
define the component instantiation in multiple smaller functions so that
it is clear to the reader whether the dependencies are being resolved
correctly.</p>
<h2 id="component-graph-visualization"><a class="header" href="#component-graph-visualization">Component Graph Visualization</a></h2>
<a href="https://app.excalidraw.com/l/4XqkU6POmGI/2PCintQJN3m" target="_blank">
    <div style="pointer-events: none;">
        <embed src="../images/daytime-greeter-graph.svg"
            width="100%"
        />
    </div>
</a>
<h2 id="reader-monad"><a class="header" href="#reader-monad">Reader Monad</a></h2>
<p>Readers coming from a functional programming background might notice
that the context pattern looks similar to the reader monad pattern. This is
correct, as we are defining a global <code>Context</code> type and passing it around as a
function argument to all code that requires the context. Additionally, we make
use of the trait (typeclass) system in Rust for compile-time dependency
injection, and the same pattern can be applied for the context type used in
reader monads.</p>
<p>For Rust readers, the main difference of the pattern described here with the
reader monad is that we are passing the context value as an explicit argument
without making use of any monadic constructs. Doing it this way is slightly more
verbose, but the upside is that we still get to enjoy much of the benefits of
the reader monad pattern without requiring Rust programmers to learn what a
monad really is (though if you're comfortable with using <code>Result</code> and <code>Option</code>,
you've already been making use of monads).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="person-querier"><a class="header" href="#person-querier">Person Querier</a></h1>
<p>We now look at the problem of having multiple context implementations,
as well as how to deduplicate them. For this we will focus on just the
implementation for <code>PersonQuerier</code> that is being used by <code>SimpleGreeter</code>.</p>
<p>The requirement for querying a person details can be implemented in many
ways, such as using a key-value store (KV store) or an SQL database.
Now suppose we have the following API for a KV store:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FsKvStore { /* ... */ }
struct KvStoreError { /* ... */ }

impl FsKvStore {
    fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, KvStoreError&gt; {
        unimplemented!() // stub
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>We could implement <code>PersonQuerier</code> for any context type that
contains <code>FsKvStore</code> in its field:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">
</span><span class="boring">struct FsKvStore { /* ... */ }
</span><span class="boring">struct KvStoreError { /* ... */ }
</span><span class="boring">
</span><span class="boring">impl FsKvStore {
</span><span class="boring">     fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, KvStoreError&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">     // ...
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>struct BasicPerson {
    name: String,
}

struct ParseError { /* ... */ }

impl TryFrom&lt;Vec&lt;u8&gt;&gt; for BasicPerson {
    type Error = ParseError;

    fn try_from(bytes: Vec&lt;u8&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        unimplemented!() // stub
    }
}

struct AppContext {
    kv_store: FsKvStore,
    // ...
}

enum AppError {
    KvStore(KvStoreError),
    Parse(ParseError),
    // ...
}

impl HasError for AppContext {
    type Error = AppError;
}

impl PersonContext for AppContext {
    type PersonId = String;
    type Person = BasicPerson;
}

impl PersonQuerier for AppContext {
    fn query_person(&amp;self, person_id: &amp;Self::PersonId)
        -&gt; Result&lt;Self::Person, Self::Error&gt;
    {
        let key = format!(&quot;persons/{}&quot;, person_id);
        let bytes = self.kv_store.get(&amp;key)
            .map_err(AppError::KvStore)?;

        let person = bytes.try_into()
            .map_err(AppError::Parse)?;

        Ok(person)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Even this simplified version of the implementation for <code>query_person</code> involves
quite a bit of logic. First, we need to implement serialization logic
to parse <code>BasicPerson</code> from raw bytes. We also need to implement the logic
of mapping the namespaced key from the person ID, as well as mapping
the errors in each operation into <code>AppError</code>s.</p>
<p>Fortunately, with the context traits design pattern, components like
<code>SimpleGreeter</code> do not need to be aware of how <code>PersonQuerier</code> is
implemented, or the existence of the key-value store in the context.
However, it would still be problematic if we need to re-implement
<code>PersonQuerier</code> for every new context type that we implement.</p>
<p>To avoid copying the body of <code>query_person</code> for all context types,
we want to have a <em>generic</em> implementation of <code>PersonQuerier</code>
for <em>any</em> context that has <code>FsKvStore</code> in one of its fields.
But if we recall from earlier sections, we already came up with
the design pattern for implementing context-generic components
like <code>Greeter</code>. So why not just turn <code>PersonQuerier</code> itself
into a context-generic component?</p>
<p>In fact, with a little re-arrangement, we can redefine
<code>PersonQuerier</code> as <code>PersonQuerier</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person;
</span><span class="boring">}
</span><span class="boring">
</span>trait PersonQuerier&lt;Context&gt;
where
    Context: PersonContext + HasError,
{
     fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
         -&gt; Result&lt;Context::Person, Context::Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>We now have a <code>PersonQuerier</code> component that is parameterized by a generic
<code>Context</code> type, and it looks very similar to how we define <code>Greeter</code>.
With this, we can now define a context-generic implementation of
<code>PersonQuerier</code> for any context that has an <code>FsKvStore</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">
</span><span class="boring">struct FsKvStore { /* ... */ }
</span><span class="boring">struct KvStoreError { /* ... */ }
</span><span class="boring">
</span><span class="boring">impl FsKvStore {
</span><span class="boring">     fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, KvStoreError&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">     // ...
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">        fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">            -&gt; Result&lt;Context::Person, Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait KvStoreContext {
    fn kv_store(&amp;self) -&gt; &amp;FsKvStore;
}

struct KvStorePersonQuerier;

impl&lt;Context, PersonId, Person, Error, ParseError&gt;
    PersonQuerier&lt;Context&gt; for KvStorePersonQuerier
where
    Context: KvStoreContext,
    Context: PersonContext&lt;Person=Person, PersonId=PersonId&gt;,
    Context: HasError&lt;Error=Error&gt;,
    PersonId: Display,
    Person: TryFrom&lt;Vec&lt;u8&gt;, Error=ParseError&gt;,
    Error: From&lt;KvStoreError&gt;,
    Error: From&lt;ParseError&gt;,
{
    fn query_person(context: &amp;Context, person_id: &amp;PersonId)
        -&gt; Result&lt;Person, Error&gt;
    {
        let key = format!(&quot;persons/{}&quot;, person_id);

        let bytes = context.kv_store().get(&amp;key)?;

        let person = bytes.try_into()?;

        Ok(person)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We first define a <code>KvStoreContext</code> trait, which allows us to extract
a reference to <code>FsKvStore</code> out of a context that implements it.
Following that, we define <code>KvStorePersonQuerier</code> as an empty struct,
similar to how we defined <code>SimpleGreeter</code>.</p>
<p>We then implement <code>PersonQuerier</code> for <code>KvStorePersonQuerier</code> to
work with any <code>Context</code> type, given that several additional constraints
are satisfied. We also use explicit type parameter bindings to simplify
the specification of our constraints.</p>
<p>We require <code>Context</code> to implement <code>KvStoreContext</code>, so that we can
extract <code>FsKvStore</code> from it. We also require <code>Context::PersonId</code> to
implement <code>Display</code> so that we can format the key as a string. Similarly,
we require that <code>Context::Person</code> implements <code>TryFrom&lt;Vec&lt;u8&gt;&gt;</code>
and bind the conversion error to an additional type binding <code>ParseError</code>.</p>
<p>The above bindings essentially make it possible for <code>KvStorePersonQuerier</code>
to work with not only any context that provides <code>FsKvStore</code>, but also
any <code>Context::PersonId</code> and <code>Context::Person</code> types as long as they
implement the <code>Display</code> and <code>TryFrom</code> traits.</p>
<p>We additionally require <code>Context::Error</code> to allow injection of sub-errors
from <code>KvStoreError</code> and <code>ParseError</code>, so that we can propagate the errors
inside <code>query_person</code>. If an error arises either when fetching bytes from the
store via the <code>context.kv_store().get()</code> call, or when parsing those bytes via
the <code>bytes.try_into()</code> call, the <code>?</code> operator will implicitly call <code>into()</code>
appropriately in order to coerce the error into an <code>Error</code>.</p>
<h2 id="generic-store"><a class="header" href="#generic-store">Generic Store</a></h2>
<p>We managed to get <code>KvStorePersonQuerier</code> we defined earlier to not only
work with a generic context containing an <code>FsKvStore</code>, but also work
with any <code>PersonId</code> and <code>Person</code> types that satisfy certain constraints.</p>
<p>We can further generalize the implementation of <code>KvStorePersonQuerier</code>
to work with <em>any</em> key-value store implementation. With that, we can easily
swap our store implementation from file-based to memory-based.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">        fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">            -&gt; Result&lt;Context::Person, Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait KvStore: HasError {
    fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt;;
}

trait KvStoreContext {
    type Store: KvStore;

    fn store(&amp;self) -&gt; &amp;Self::Store;
}

struct KvStorePersonQuerier;

impl&lt;Context, Store, PersonId, Person, Error, ParseError, StoreError&gt;
    PersonQuerier&lt;Context&gt; for KvStorePersonQuerier
where
    Context: KvStoreContext&lt;Store=Store&gt;,
    Context: PersonContext&lt;Person=Person, PersonId=PersonId&gt;,
    Context: HasError&lt;Error=Error&gt;,
    Store: KvStore&lt;Error=StoreError&gt;,
    PersonId: Display,
    Person: TryFrom&lt;Vec&lt;u8&gt;, Error=ParseError&gt;,
    Error: From&lt;StoreError&gt;,
    Error: From&lt;ParseError&gt;,
{
    fn query_person(context: &amp;Context, person_id: &amp;PersonId)
        -&gt; Result&lt;Person, Error&gt;
    {
        let key = format!(&quot;persons/{}&quot;, person_id);

        let bytes = context.store().get(&amp;key)?;

        let person = bytes.try_into()?;

        Ok(person)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We first define a <code>KvStore</code> trait that provides a <code>get</code> method for reading
values from the store. It also has <code>HasError</code> as its supertrait, so
that we can reuse the <code>Error</code> associated type.</p>
<p>We then redefine the <code>KvStoreContext</code> to contain an associated type <code>Store</code>,
which is required to implement the <code>KvStore</code> trait. We then make the
<code>store</code> method return a reference to <code>Self::Store</code>.</p>
<p>Inside the <code>PersonQuerier</code> implementation for <code>KvStorePersonQuerier</code>, we
introduce two new explicit type bindings: <code>Store</code> for <code>Context::Store</code>,
and <code>StoreError</code> for <code>Store::Error</code>. We also require the main
<code>Error</code> type to implement <code>From&lt;StoreError&gt;</code> so that any error from
the store can be propagated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="querier-consumer"><a class="header" href="#querier-consumer">Querier Consumer</a></h1>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait KvStore: HasError {
</span><span class="boring">     fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait KvStoreContext {
</span><span class="boring">     type Store: KvStore;
</span><span class="boring">
</span><span class="boring">     fn store(&amp;self) -&gt; &amp;Self::Store;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KvStorePersonQuerier;
</span><span class="boring">
</span><span class="boring">impl&lt;Context, Store, PersonId, Person, Error, ParseError, StoreError&gt;
</span><span class="boring">     PersonQuerier&lt;Context&gt; for KvStorePersonQuerier
</span><span class="boring">where
</span><span class="boring">     Context: KvStoreContext&lt;Store=Store&gt;,
</span><span class="boring">     Context: PersonContext&lt;Person=Person, PersonId=PersonId&gt;,
</span><span class="boring">     Context: HasError&lt;Error=Error&gt;,
</span><span class="boring">     Store: KvStore&lt;Error=StoreError&gt;,
</span><span class="boring">     PersonId: Display,
</span><span class="boring">     Person: TryFrom&lt;Vec&lt;u8&gt;, Error=ParseError&gt;,
</span><span class="boring">     Error: From&lt;StoreError&gt;,
</span><span class="boring">     Error: From&lt;ParseError&gt;,
</span><span class="boring">{
</span><span class="boring">     fn query_person(context: &amp;Context, person_id: &amp;PersonId)
</span><span class="boring">         -&gt; Result&lt;Person, Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let key = format!(&quot;persons/{}&quot;, person_id);
</span><span class="boring">
</span><span class="boring">         let bytes = context.store().get(&amp;key)?;
</span><span class="boring">
</span><span class="boring">         let person = bytes.try_into()?;
</span><span class="boring">
</span><span class="boring">         Ok(person)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">        fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">            -&gt; Result&lt;Context::Person, Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleGreeter;

impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
where
    Context: PersonContext + HasError,
    KvStorePersonQuerier: PersonQuerier&lt;Context&gt;,
{
    fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
        -&gt; Result&lt;(), Context::Error&gt;
    {
        let person = KvStorePersonQuerier::query_person(context, person_id)?;
        println!(&quot;Hello, {}&quot;, person.name());
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-querier-consumer"><a class="header" href="#generic-querier-consumer">Generic Querier Consumer</a></h2>
<p>Now that we have a context-generic implementation of <code>KvStorePersonQuerier</code>,
we can try to use it from <code>SimpleGreeter</code>. To do that, <code>SimpleGreeter</code> has
to somehow get <code>KvStorePersonQuerier</code> from <code>Context</code> and use it as a
<code>PersonQuerier</code>.</p>
<p>Recall that <code>KvStorePersonQuerier</code> itself is not a context (though it does
implement <code>PersonQuerier&lt;Context&gt;</code> in order to query a context), and therefore
it does not implement other context traits like <code>PersonContext</code>. What we
need instead is for concrete contexts like <code>AppContext</code> to specify that
their implementation of <code>PersonQuerier</code> is <code>KvStorePersonQuerier</code>.
We can do that by defining a <code>HasPersonQuerier</code> trait as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait PersonQuerier&lt;Context&gt;
where
    Context: PersonContext + HasError,
{
     fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
         -&gt; Result&lt;Context::Person, Context::Error&gt;;
}

trait HasPersonQuerier:
    PersonContext + HasError + Sized
{
    type PersonQuerier: PersonQuerier&lt;Self&gt;;

    fn query_person(&amp;self, person_id: &amp;Self::PersonId)
        -&gt; Result&lt;Self::Person, Self::Error&gt;
    {
        Self::PersonQuerier::query_person(self, person_id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>While the <code>PersonQuerier</code> trait is implemented by component types like
<code>KvStorePersonQuerier</code>, the <code>HasPersonQuerier</code> trait is implemented by
context types like <code>AppContext</code>. Compared to the earlier design of
<code>PersonQuerier</code>, the context is now offering a <em>component</em> for
querying for a person that will work in the <em>current context</em>.</p>
<p>We can see that the <code>HasPersonQuerier</code> trait has <code>PersonContext</code>
and <code>HasError</code> as its supertraits, indicating that the concrete context
also needs to implement these two traits first. Due to quirks in Rust,
the trait also requires the <code>Sized</code> supertrait, which is already implemented
by most types other than <code>dyn Trait</code> types, so that we can use <code>Self</code> inside
other generic parameters.</p>
<p>In the body of <code>HasPersonQuerier</code>, we define a <code>PersonQuerier</code> associated
type, which implements the trait <code>PersonQuerier&lt;Self&gt;</code>. This is because
we want to have the following constraints satisfied:</p>
<ul>
<li><code>AppContext: HasPersonQuerier</code> - <code>AppContext</code> implements the trait <code>HasPersonQuerier</code>.</li>
<li><code>AppContext::PersonQuerier: PersonQuerier&lt;AppContext&gt;</code> - The associated type
<code>AppContext::PersonQuerier</code> implements the trait <code>PersonQuerier&lt;AppContext&gt;</code>.</li>
<li><code>KvStorePersonQuerier: PersonQuerier&lt;AppContext&gt;</code> - The type <code>KvStorePersonQuerier</code>,
which we defined earlier, should implement <code>PersonQuerier&lt;AppContext&gt;</code>.</li>
<li><code>AppContext: HasPersonQuerier&lt;PersonQuerier=KvStorePersonQuerier&gt;</code> - We want to
set the associated type <code>AppContext::PersonQuerier</code> to be <code>KvStorePersonQuerier</code>.</li>
</ul>
<p>In general, since we want any type <code>Ctx</code> that implements <code>HasPersonQuerier</code> to
have the associated type <code>Ctx::PersonQuerier</code> to implement <code>PersonQuerier&lt;Ctx&gt;</code>.
Hence inside the trait definition, we define the associated type as
<code>type PersonQuerier: PersonQuerier&lt;Self&gt;</code>, where <code>Self</code> refers to the <code>Ctx</code> type.</p>
<p>This may look a little self-referential, as the context is providing a type
that is referencing back to itself. But with the dependency injection mechanism
of the traits system, this in fact works most of the time as long as there are
no actual cyclic dependencies.</p>
<p>Inside <code>HasPersonQuerier</code>, we also implement a <code>query_person</code> method with a <code>&amp;self</code>,
which calls <code>Self::PersonQuerier::query_person</code> to do the actual query. This method
is not meant to be overridden by implementations. Rather, it is a convenient method
that allows us to query from the context directly using <code>context.query_person()</code>.</p>
<p>Now inside the <code>Greet</code> implementation for <code>SimpleGreeter</code>, we can require the
generic <code>Context</code> to implement <code>HasPersonQuerier</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">    Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;Context::Person, Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasPersonQuerier:
</span><span class="boring">    PersonContext + HasError + Sized
</span><span class="boring">{
</span><span class="boring">    type PersonQuerier: PersonQuerier&lt;Self&gt;;
</span><span class="boring">
</span><span class="boring">    fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">        -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">    {
</span><span class="boring">        Self::PersonQuerier::query_person(self, person_id)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleGreeter;

impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
where
    Context: HasPersonQuerier,
{
    fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
        -&gt; Result&lt;(), Context::Error&gt;
    {
        let person = context.query_person(person_id)?;
        println!(&quot;Hello, {}&quot;, person.name());
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Inside the <code>greet</code> method, we can call <code>context.query_person()</code> and pass in
the <code>context</code> as the first argument to query for the person details.</p>
<p>In summary, what we achieved at this point is as follows:</p>
<ul>
<li>We define a context-generic component for <code>PersonQuerier</code> as
<code>KvStorePersonQuerier</code>.</li>
<li>We define another context-generic component for <code>Greet</code> as <code>SimpleGreeter</code>,
which <em>depends</em> on a <code>PersonQuerier</code> component provided from the context.</li>
<li>The Rust trait system <em>resolves</em> the dependency graph, constructs a
<code>KvStorePersonQuerier</code> using its <em>indirect dependencies</em> from the context,
and passes it as the <code>PersonQuerier</code> dependency to <code>SimpleGreeter</code>.</li>
</ul>
<p>By using dependency injection, we don't need to know about the fact that in
order to build <code>SimpleGreeter</code>, we need to first build <code>KvStorePersonQuerier</code>,
but in order to build <code>KvStorePersonQuerier</code>, we need to first build
<code>FsKvStore</code>.</p>
<p>By leveraging dependency injection, we don't need to know that building
<code>SimpleGreeter</code> requires first building <code>KvStorePersonQuerier</code>, which itself
requires first building <code>FsKvStore</code>. The compiler resolves all of these
dependencies at compile time for free, and we do not even need to pay for the
cost of doing such wiring at run time.</p>
<h2 id="selfless-components"><a class="header" href="#selfless-components">Selfless Components</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait PersonQuerier&lt;Context&gt;
where
    Context: PersonContext + HasError,
{
     fn query_person(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
         -&gt; Result&lt;Context::Person, Context::Error&gt;;
}

trait HasPersonQuerier:
    PersonContext + HasError + Sized
{
    type PersonQuerier: PersonQuerier&lt;Self&gt;;

    fn person_querier(&amp;self) -&gt; &amp;Self::PersonQuerier;
}

struct SimpleGreeter;

impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
where
    Context: HasPersonQuerier,
{
    fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
        -&gt; Result&lt;(), Context::Error&gt;
    {
        let person = context.person_querier().query_person(context, person_id)?;
        println!(&quot;Hello, {}&quot;, person.name());
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-implementation"><a class="header" href="#store-implementation">Store Implementation</a></h1>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">        fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">            -&gt; Result&lt;Context::Person, Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait KvStore: HasError {
</span><span class="boring">     fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait KvStoreContext {
</span><span class="boring">     type Store: KvStore;
</span><span class="boring">
</span><span class="boring">     fn store(&amp;self) -&gt; &amp;Self::Store;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KvStorePersonQuerier;
</span><span class="boring">
</span><span class="boring">impl&lt;Context, Store, PersonId, Person, Error, ParseError, StoreError&gt;
</span><span class="boring">     PersonQuerier&lt;Context&gt; for KvStorePersonQuerier
</span><span class="boring">where
</span><span class="boring">     Context: KvStoreContext&lt;Store=Store&gt;,
</span><span class="boring">     Context: PersonContext&lt;Person=Person, PersonId=PersonId&gt;,
</span><span class="boring">     Context: HasError&lt;Error=Error&gt;,
</span><span class="boring">     Store: KvStore&lt;Error=StoreError&gt;,
</span><span class="boring">     PersonId: Display,
</span><span class="boring">     Person: TryFrom&lt;Vec&lt;u8&gt;, Error=ParseError&gt;,
</span><span class="boring">     Error: From&lt;StoreError&gt;,
</span><span class="boring">     Error: From&lt;ParseError&gt;,
</span><span class="boring">{
</span><span class="boring">     fn query_person(context: &amp;Context, person_id: &amp;PersonId)
</span><span class="boring">         -&gt; Result&lt;Person, Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let key = format!(&quot;persons/{}&quot;, person_id);
</span><span class="boring">
</span><span class="boring">         let bytes = context.store().get(&amp;key)?;
</span><span class="boring">
</span><span class="boring">         let person = bytes.try_into()?;
</span><span class="boring">
</span><span class="boring">         Ok(person)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasPersonQuerier:
</span><span class="boring">     PersonContext + HasError + Sized
</span><span class="boring">{
</span><span class="boring">     type PersonQuerier: PersonQuerier&lt;Self&gt;;
</span><span class="boring">
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         Self::PersonQuerier::query_person(self, person_id)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleGreeter;
</span><span class="boring">
</span><span class="boring">impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
</span><span class="boring">where
</span><span class="boring">     Context: HasPersonQuerier,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let person = context.query_person(person_id)?;
</span><span class="boring">         println!(&quot;Hello, {}&quot;, person.name());
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct BasicPerson {
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl NamedPerson for BasicPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str {
</span><span class="boring">         &amp;self.name
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>struct FsKvStore { /* ... */ }
struct KvStoreError { /* ... */ }

struct ParseError { /* ... */ }

impl HasError for FsKvStore {
    type Error = KvStoreError;
}

impl KvStore for FsKvStore {
    fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {
        unimplemented!() // stub
    }
}

impl TryFrom&lt;Vec&lt;u8&gt;&gt; for BasicPerson {
    type Error = ParseError;

    fn try_from(bytes: Vec&lt;u8&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        unimplemented!() // stub
    }
}

enum AppError {
    KvStore(KvStoreError),
    Parse(ParseError),
    // ...
}

impl From&lt;KvStoreError&gt; for AppError {
    fn from(err: KvStoreError) -&gt; Self {
        Self::KvStore(err)
    }
}

impl From&lt;ParseError&gt; for AppError {
    fn from(err: ParseError) -&gt; Self {
        Self::Parse(err)
    }
}

struct AppContext {
    kv_store: FsKvStore,
    // ...
}

impl HasError for AppContext {
    type Error = AppError;
}

impl PersonContext for AppContext {
    type PersonId = String;
    type Person = BasicPerson;
}

impl KvStoreContext for AppContext {
    type Store = FsKvStore;

    fn store(&amp;self) -&gt; &amp;Self::Store {
        &amp;self.kv_store
    }
}

impl HasPersonQuerier for AppContext {
    type PersonQuerier = KvStorePersonQuerier;
}

fn app_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
    SimpleGreeter
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="multiple-context-implementations"><a class="header" href="#multiple-context-implementations">Multiple Context Implementations</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">        fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">            -&gt; Result&lt;Context::Person, Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait KvStore: HasError {
</span><span class="boring">     fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait KvStoreContext {
</span><span class="boring">     type Store: KvStore;
</span><span class="boring">
</span><span class="boring">     fn store(&amp;self) -&gt; &amp;Self::Store;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KvStorePersonQuerier;
</span><span class="boring">
</span><span class="boring">impl&lt;Context, Store, PersonId, Person, Error, ParseError, StoreError&gt;
</span><span class="boring">     PersonQuerier&lt;Context&gt; for KvStorePersonQuerier
</span><span class="boring">where
</span><span class="boring">     Context: KvStoreContext&lt;Store=Store&gt;,
</span><span class="boring">     Context: PersonContext&lt;Person=Person, PersonId=PersonId&gt;,
</span><span class="boring">     Context: HasError&lt;Error=Error&gt;,
</span><span class="boring">     Store: KvStore&lt;Error=StoreError&gt;,
</span><span class="boring">     PersonId: Display,
</span><span class="boring">     Person: TryFrom&lt;Vec&lt;u8&gt;, Error=ParseError&gt;,
</span><span class="boring">     Error: From&lt;StoreError&gt;,
</span><span class="boring">     Error: From&lt;ParseError&gt;,
</span><span class="boring">{
</span><span class="boring">     fn query_person(context: &amp;Context, person_id: &amp;PersonId)
</span><span class="boring">         -&gt; Result&lt;Person, Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let key = format!(&quot;persons/{}&quot;, person_id);
</span><span class="boring">
</span><span class="boring">         let bytes = context.store().get(&amp;key)?;
</span><span class="boring">
</span><span class="boring">         let person = bytes.try_into()?;
</span><span class="boring">
</span><span class="boring">         Ok(person)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasPersonQuerier:
</span><span class="boring">     PersonContext + HasError + Sized
</span><span class="boring">{
</span><span class="boring">     type PersonQuerier: PersonQuerier&lt;Self&gt;;
</span><span class="boring">
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         Self::PersonQuerier::query_person(self, person_id)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleGreeter;
</span><span class="boring">
</span><span class="boring">impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
</span><span class="boring">where
</span><span class="boring">     Context: HasPersonQuerier,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let person = context.query_person(person_id)?;
</span><span class="boring">         println!(&quot;Hello, {}&quot;, person.name());
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct BasicPerson {
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl NamedPerson for BasicPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str {
</span><span class="boring">         &amp;self.name
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FsKvStore { /* ... */ }
</span><span class="boring">struct KvStoreError { /* ... */ }
</span><span class="boring">
</span><span class="boring">struct ParseError { /* ... */ }
</span><span class="boring">
</span><span class="boring">impl HasError for FsKvStore {
</span><span class="boring">     type Error = KvStoreError;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl KvStore for FsKvStore {
</span><span class="boring">     fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;Vec&lt;u8&gt;&gt; for BasicPerson {
</span><span class="boring">     type Error = ParseError;
</span><span class="boring">
</span><span class="boring">     fn try_from(bytes: Vec&lt;u8&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum AppError {
</span><span class="boring">     KvStore(KvStoreError),
</span><span class="boring">     Parse(ParseError),
</span><span class="boring">     // ...
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;KvStoreError&gt; for AppError {
</span><span class="boring">     fn from(err: KvStoreError) -&gt; Self {
</span><span class="boring">         Self::KvStore(err)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;ParseError&gt; for AppError {
</span><span class="boring">     fn from(err: ParseError) -&gt; Self {
</span><span class="boring">         Self::Parse(err)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>struct Foo;
struct Bar;

struct FooContext {
    kv_store: FsKvStore,
    foo: Foo,
    // ...
}

struct BarContext {
    kv_store: FsKvStore,
    bar: Bar,
    // ...
}

impl HasError for FooContext {
    type Error = AppError;
}

impl HasError for BarContext {
    type Error = AppError;
}

impl PersonContext for FooContext {
    type PersonId = String;
    type Person = BasicPerson;
}

impl PersonContext for BarContext {
    type PersonId = String;
    type Person = BasicPerson;
}

impl KvStoreContext for FooContext {
    type Store = FsKvStore;

    fn store(&amp;self) -&gt; &amp;Self::Store {
        &amp;self.kv_store
    }
}

impl KvStoreContext for BarContext {
    type Store = FsKvStore;

    fn store(&amp;self) -&gt; &amp;Self::Store {
        &amp;self.kv_store
    }
}

impl HasPersonQuerier for FooContext {
    type PersonQuerier = KvStorePersonQuerier;
}

impl HasPersonQuerier for BarContext {
    type PersonQuerier = KvStorePersonQuerier;
}

fn foo_greeter() -&gt; impl Greeter&lt;FooContext&gt; {
    SimpleGreeter
}

fn bar_greeter() -&gt; impl Greeter&lt;BarContext&gt; {
    SimpleGreeter
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching-querier"><a class="header" href="#caching-querier">Caching Querier</a></h1>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::hash::Hash;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person;
</span><span class="boring">}
</span><span class="boring">
</span>trait PersonQuerier&lt;Context&gt;
where
    Context: PersonContext + HasError,
{
    fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
        -&gt; Result&lt;Context::Person, Context::Error&gt;;
}

trait PersonCacheContext: PersonContext {
    fn person_cache(&amp;self) -&gt; &amp;HashMap&lt;Self::PersonId, Self::Person&gt;;
}

struct CachingPersonQuerier&lt;InQuerier&gt;(InQuerier);

impl&lt;Context, InQuerier&gt; PersonQuerier&lt;Context&gt;
    for CachingPersonQuerier&lt;InQuerier&gt;
where
    InQuerier: PersonQuerier&lt;Context&gt;,
    Context: PersonCacheContext,
    Context: HasError,
    Context::PersonId: Hash + Eq,
    Context::Person: Clone,
{
    fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
        -&gt; Result&lt;Context::Person, Context::Error&gt;
    {
        let entry = context.person_cache().get(person_id);

        match entry {
            Some(person) =&gt; Ok(person.clone()),
            None =&gt; InQuerier::query_person(context, person_id),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="caching-app-context"><a class="header" href="#caching-app-context">Caching App Context</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::hash::Hash;
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use std::convert::{TryFrom, TryInto};
</span><span class="boring">
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">        fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">            -&gt; Result&lt;Context::Person, Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait KvStore: HasError {
</span><span class="boring">     fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait KvStoreContext {
</span><span class="boring">     type Store: KvStore;
</span><span class="boring">
</span><span class="boring">     fn store(&amp;self) -&gt; &amp;Self::Store;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct KvStorePersonQuerier;
</span><span class="boring">
</span><span class="boring">impl&lt;Context, Store, PersonId, Person, Error, ParseError, StoreError&gt;
</span><span class="boring">     PersonQuerier&lt;Context&gt; for KvStorePersonQuerier
</span><span class="boring">where
</span><span class="boring">     Context: KvStoreContext&lt;Store=Store&gt;,
</span><span class="boring">     Context: PersonContext&lt;Person=Person, PersonId=PersonId&gt;,
</span><span class="boring">     Context: HasError&lt;Error=Error&gt;,
</span><span class="boring">     Store: KvStore&lt;Error=StoreError&gt;,
</span><span class="boring">     PersonId: Display,
</span><span class="boring">     Person: TryFrom&lt;Vec&lt;u8&gt;, Error=ParseError&gt;,
</span><span class="boring">     Error: From&lt;StoreError&gt;,
</span><span class="boring">     Error: From&lt;ParseError&gt;,
</span><span class="boring">{
</span><span class="boring">     fn query_person(context: &amp;Context, person_id: &amp;PersonId)
</span><span class="boring">         -&gt; Result&lt;Person, Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let key = format!(&quot;persons/{}&quot;, person_id);
</span><span class="boring">
</span><span class="boring">         let bytes = context.store().get(&amp;key)?;
</span><span class="boring">
</span><span class="boring">         let person = bytes.try_into()?;
</span><span class="boring">
</span><span class="boring">         Ok(person)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasPersonQuerier:
</span><span class="boring">     PersonContext + HasError + Sized
</span><span class="boring">{
</span><span class="boring">     type PersonQuerier: PersonQuerier&lt;Self&gt;;
</span><span class="boring">
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         Self::PersonQuerier::query_person(self, person_id)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleGreeter;
</span><span class="boring">
</span><span class="boring">impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
</span><span class="boring">where
</span><span class="boring">     Context: HasPersonQuerier,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let person = context.query_person(person_id)?;
</span><span class="boring">         println!(&quot;Hello, {}&quot;, person.name());
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Clone)]
struct BasicPerson {
    name: String,
}

<span class="boring">impl NamedPerson for BasicPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str {
</span><span class="boring">         &amp;self.name
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonCacheContext: PersonContext {
</span><span class="boring">     fn person_cache(&amp;self) -&gt; &amp;HashMap&lt;Self::PersonId, Self::Person&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct CachingPersonQuerier&lt;InQuerier&gt;(InQuerier);
</span><span class="boring">
</span><span class="boring">impl&lt;Context, InQuerier&gt; PersonQuerier&lt;Context&gt;
</span><span class="boring">     for CachingPersonQuerier&lt;InQuerier&gt;
</span><span class="boring">where
</span><span class="boring">     InQuerier: PersonQuerier&lt;Context&gt;,
</span><span class="boring">     Context: PersonCacheContext,
</span><span class="boring">     Context: HasError,
</span><span class="boring">     Context::PersonId: Hash + Eq,
</span><span class="boring">     Context::Person: Clone,
</span><span class="boring">{
</span><span class="boring">     fn query_person(context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;Context::Person, Context::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let entry = context.person_cache().get(person_id);
</span><span class="boring">
</span><span class="boring">         match entry {
</span><span class="boring">             Some(person) =&gt; Ok(person.clone()),
</span><span class="boring">             None =&gt; InQuerier::query_person(context, person_id),
</span><span class="boring">         }
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FsKvStore { /* ... */ }
</span><span class="boring">struct KvStoreError { /* ... */ }
</span><span class="boring">
</span><span class="boring">struct ParseError { /* ... */ }
</span><span class="boring">
</span><span class="boring">impl HasError for FsKvStore {
</span><span class="boring">     type Error = KvStoreError;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl KvStore for FsKvStore {
</span><span class="boring">     fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;Vec&lt;u8&gt;&gt; for BasicPerson {
</span><span class="boring">     type Error = ParseError;
</span><span class="boring">
</span><span class="boring">     fn try_from(bytes: Vec&lt;u8&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum AppError {
</span><span class="boring">     KvStore(KvStoreError),
</span><span class="boring">     Parse(ParseError),
</span><span class="boring">     // ...
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;KvStoreError&gt; for AppError {
</span><span class="boring">     fn from(err: KvStoreError) -&gt; Self {
</span><span class="boring">         Self::KvStore(err)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;ParseError&gt; for AppError {
</span><span class="boring">     fn from(err: ParseError) -&gt; Self {
</span><span class="boring">         Self::Parse(err)
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>struct AppContext {
    kv_store: FsKvStore,
    person_cache: HashMap&lt;String, BasicPerson&gt;,
    // ...
}

<span class="boring">impl HasError for AppContext {
</span><span class="boring">     type Error = AppError;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PersonContext for AppContext {
</span><span class="boring">     type PersonId = String;
</span><span class="boring">     type Person = BasicPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl KvStoreContext for AppContext {
</span><span class="boring">     type Store = FsKvStore;
</span><span class="boring">
</span><span class="boring">     fn store(&amp;self) -&gt; &amp;Self::Store {
</span><span class="boring">         &amp;self.kv_store
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>impl PersonCacheContext for AppContext {
    fn person_cache(&amp;self) -&gt; &amp;HashMap&lt;String, BasicPerson&gt; {
        &amp;self.person_cache
    }
}

impl HasPersonQuerier for AppContext {
    type PersonQuerier = CachingPersonQuerier&lt;KvStorePersonQuerier&gt;;
}

fn app_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
    SimpleGreeter
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
