<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Daytime Greeter - Context-Generic Programming Guide (DRAFT)</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Beginner Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../beginner/01-simple-greeter.html"><strong aria-hidden="true">2.1.</strong> Simple Greeter</a></li><li class="chapter-item expanded "><a href="../beginner/02-generic-context.html"><strong aria-hidden="true">2.2.</strong> Generic Context</a></li><li class="chapter-item expanded "><a href="../beginner/03-context-implementation.html"><strong aria-hidden="true">2.3.</strong> Context Implementation</a></li><li class="chapter-item expanded "><a href="../beginner/04-greeter-component.html"><strong aria-hidden="true">2.4.</strong> Greeter Component</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Intermediate Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intermediate/01-daytime-greeter.html" class="active"><strong aria-hidden="true">3.1.</strong> Daytime Greeter</a></li><li class="chapter-item expanded "><a href="../intermediate/02-component-composition.html"><strong aria-hidden="true">3.2.</strong> Component Composition</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Advanced Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/01-person-querier.html"><strong aria-hidden="true">4.1.</strong> Person Querier</a></li><li class="chapter-item expanded "><a href="../advanced/02-querier-consumer.html"><strong aria-hidden="true">4.2.</strong> Querier Consumer</a></li><li class="chapter-item expanded "><a href="../advanced/03-store-impl.html"><strong aria-hidden="true">4.3.</strong> Store Implementation</a></li><li class="chapter-item expanded "><a href="../advanced/04-caching-querier.html"><strong aria-hidden="true">4.4.</strong> Caching Querier</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Context-Generic Programming Guide (DRAFT)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="daytime-greeter"><a class="header" href="#daytime-greeter">Daytime Greeter</a></h1>
<p>Now suppose that we want to extend our greeter component such that it only
greets a person at day time during office hours. We could directly modify
the <code>Greeter</code> implementation for <code>SimpleGreeter</code> to do that, but that may
complicate the implementation and makes it more difficult to understand
the core logic. Alternatively, we could define a new <code>DaytimeGreeter</code>
component that <em>wraps</em> around the original <code>SimpleGreeter</code>.</p>
<p>This new <code>DaytimeGreeter</code> component would need to know how to
get the current time of the system, as well as how to tell whether
a given time value is at daytime. Following the context pattern we
learned, we will also define a <code>HasTime</code> trait for getting the time:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SimpleTime {
    fn is_daytime(&amp;self) -&gt; bool;
}

trait HasTime {
    type Time;

    fn now(&amp;self) -&gt; Self::Time;
}
<span class="boring">}
</span></code></pre></pre>
<p>For demonstration purposes, we first define a <code>SimpleTime</code> trait that provides an
<code>is_daytime</code> method to tell whether the current time value is considered daytime.
Following that, we define a <code>HasTime</code> trait that provides a <code>now</code> method
to fetch the current time from the context. Notice that the associated type
<code>Time</code> does <em>not</em> implement <code>SimpleTime</code>. This is so that we can learn how
to inject the <code>SimpleTime</code> constraint as an <em>indirect dependency</em> using the
same dependency injection technique.</p>
<p>We then define the <code>DaytimeGreeter</code> component as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait SimpleTime {
</span><span class="boring">    fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasTime {
</span><span class="boring">    type Time;
</span><span class="boring">
</span><span class="boring">    fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">    Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">    fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">        -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>struct DaytimeGreeter&lt;InGreeter&gt;(InGreeter);

impl&lt;Context, InGreeter&gt; Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
where
    InGreeter: Greeter&lt;Context&gt;,
    Context: HasTime + PersonContext + HasError,
    Context::Time: SimpleTime,
{
    fn greet(
        &amp;self,
        context: &amp;Context,
        person_id: &amp;Context::PersonId,
    ) -&gt; Result&lt;(), Context::Error&gt;
    {
        let now = context.now();
        if now.is_daytime() {
            self.0.greet(context, person_id)?;
        } else {
            println!(&quot;Sorry, the shop has closed now!&quot;);
        }
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We define the <code>DaytimeGreeter</code> with an <code>InGreeter</code> type parameter, which
would act as the inner <code>Greeter</code> component. We then define a generic
implementation of <code>Greeter&lt;Context&gt;</code> for <code>DaytimeGreeter&lt;InGreeter&gt;</code>.
In the trait bounds, we require the inner greeter <code>InGreeter</code> to also
implement <code>Greeter&lt;Context&gt;</code>, since the core logic is implemented over there.</p>
<p>Aside from <code>PersonContext</code> and <code>HasError</code>, we also require <code>Context</code>
to implement <code>HasTime</code> for <code>DaytimeGreeter</code> to fetch the current time.
Other than that, we also explicitly require that the associated type
<code>Context::Time</code> implements <code>SimpleTime</code>.</p>
<p>By specifying <code>SimpleTime</code> as an explicit dependency, we relax the requirement
of how the <code>HasTime</code> trait can be used by other components. So if
<code>SimpleTime</code> is only ever used by <code>DaytimeGreeter</code>, and if an application
does not need <code>DaytimeGreeter</code>, then a concrete context can skip implementing
<code>SimpleTime</code> for its time type, even if the trait <code>HasTime</code> is used by
other components.</p>
<h2 id="error-injection"><a class="header" href="#error-injection">Error Injection</a></h2>
<p>In our earlier implementation of <code>DaytimeGreeter</code>, the greeter simply prints
out that the shop has closed, and then returns successfully without calling
the inner greeter. But what if we want <code>DaytimeGreeter</code> to return an error
during night time? Since the associated type <code>Error</code> in <code>HasError</code>
is abstract, there is no obvious way we can construct an error value of
type <code>Error</code>.</p>
<p>On the other hand, we learned in the previous section that we can specify an
additional trait bound that <code>Context::Time</code> implements <code>SimpleTime</code>.
Similarly, we can also specify additional trait bounds for <code>Context::Error</code>
so that we gain additional knowledge of how to construct an error value.</p>
<p>We can do this by defining a custom <code>ShopClosedError</code> struct and require that
<code>Context::Error</code> implement a <code>From</code> instance for conversion from <code>ShopClosedError</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait SimpleTime {
</span><span class="boring">     fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">     fn duration_since(&amp;self, other: &amp;Self) -&gt; Duration;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasTime {
</span><span class="boring">     type Time;
</span><span class="boring">
</span><span class="boring">     fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>struct ShopClosedError&lt;Time&gt; { time: Time }

struct DaytimeGreeter&lt;InGreeter&gt;(InGreeter);

impl&lt;Context, InGreeter&gt; Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
where
    InGreeter: Greeter&lt;Context&gt;,
    Context: HasTime + PersonContext + HasError,
    Context::Time: SimpleTime,
    Context::Error: From&lt;ShopClosedError&lt;Context::Time&gt;&gt;,
{
    fn greet(
        &amp;self,
        context: &amp;Context,
        person_id: &amp;Context::PersonId,
    ) -&gt; Result&lt;(), Context::Error&gt;
    {
        let now = context.now();
        if now.is_daytime() {
            self.0.greet(context, person_id)
        } else {
            Err(ShopClosedError { time: now }.into())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>ShopClosedError</code> is parameterized by a generic <code>Time</code> type so that
it can provide details about the time that caused <code>ShopClosedError</code> to be
raised. In the <code>Greeter</code> implementation for <code>DaytimeGreeter</code> we add an
additional trait bound to require <code>Context::Error</code> to implement
<code>From&lt;ShopClosedError&lt;Context::Time&gt;&gt;</code>. With that, if the time returned
by <code>context.now()</code> is not considered daytime, we can construct a
<code>ShopClosedError</code> and turn it into <code>Context::Error</code> using the <code>into</code> method.</p>
<p>What we have done above is essentially specifying an <em>error injection method</em>
for injecting a sub-error type into the main error type. With this, individual
components do not need to know about the concrete application error and all
the possible errors that can be raised. But they can still <em>inject</em> specific
errors into the main error type by requiring additional <code>From</code> constraints.</p>
<p>For instance, <code>DaytimeGreeter</code> does not need to be aware of whether the inner
greeter component would raise a database error. From the <code>impl</code> definition,
we can be confident that <code>DaytimeGreeter</code> itself cannot raise any sub-error
other than <code>ShopClosedError</code>.</p>
<h2 id="multiple-type-bindings"><a class="header" href="#multiple-type-bindings">Multiple Type Bindings</a></h2>
<p>When specifying the constraints for indirect dependencies, we have to keep using
the <code>Context::</code> prefix to access associated types like <code>Context::Error</code>. Worse,
once we start using nested associated types, we have to resort to using fully
qualified syntax like <code>&lt;Context::Foo as Foo&gt;::Bar</code>; <code>Context::Foo::Bar</code> doesn't work.</p>
<p>To help simplify the trait bounds for components like <code>DaytimeGreeter</code>, we
can use the explicit associated type bindings we learned about earlier:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait SimpleTime {
</span><span class="boring">     fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">     fn duration_since(&amp;self, other: &amp;Self) -&gt; Duration;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasTime {
</span><span class="boring">     type Time;
</span><span class="boring">
</span><span class="boring">     fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct ShopClosedError&lt;Time&gt; { time: Time }
</span><span class="boring">
</span><span class="boring">struct DaytimeGreeter&lt;InGreeter&gt;(InGreeter);
</span><span class="boring">
</span>impl&lt;Context, InGreeter, Time, Error, PersonId&gt;
    Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
where
    InGreeter: Greeter&lt;Context&gt;,
    Context: HasError&lt;Error=Error&gt;,
    Context: PersonContext&lt;PersonId=PersonId&gt;,
    Context: HasTime&lt;Time=Time&gt;,
    Time: SimpleTime,
    Error: From&lt;ShopClosedError&lt;Time&gt;&gt;,
{
    fn greet(&amp;self, context: &amp;Context, person_id: &amp;PersonId)
        -&gt; Result&lt;(), Error&gt;
    {
        let now = context.now();
        if now.is_daytime() {
            self.0.greet(context, person_id)
        } else {
            Err(ShopClosedError { time: now }.into())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In our new <code>Greeter</code> implementation, we introduce the generic parameters
<code>Time</code>, <code>Error</code>, and <code>PersonId</code>. We then bind the types to the associated
types of the context traits, such as <code>HasError&lt;Error=Error&gt;</code>. With the
bindings in place we can have simpler trait bounds like <code>Time: SimpleTime</code>
to be specified in place of the more verbose <code>Context::Time: SimpleTime</code>.</p>
<h2 id="dynamic-typed-interpretation"><a class="header" href="#dynamic-typed-interpretation">Dynamic-Typed Interpretation</a></h2>
<pre><code class="language-javascript">function daytime_greeter(in_greeter) {
    return function(context, person_id) {
        const now = context.now()
        if now.is_daytime() {
            return in_greeter.greet(context, person_id)
        } else {
            throw new ShopeClosedError({ time: now })
        }
    }
}
</code></pre>
<pre><code class="language-javascript">function build_daytime_greeter_class(deps) {
    return Class {
        constructor(in_greeter) {
            this.in_greeter = in_greeter
        }

        greet(context, person_id) {
            const now = deps.HasTime.prototype.now.call(context)
            if deps.HasTime.Time.prototype.is_daytime.call(now) {
                return deps.InGreeter.prototype.greet.call(
                    this.in_greeter, context, person_id)
            } else {
                throw deps.HasError.Error.from(
                    new ShopeClosedError({ time: now }))
            }
        }
    }
}
</code></pre>
<pre><code class="language-javascript">const DaytimeGreeter = build_daytime_greeter_class({
    InGreeter: ...,
    HasError: {
        Error: {
            from: function(err) { ... }
        },
    },
    PersonContext: {
        PersonId: ...,
        Person: ...,
    },
    HasTime: {
        Time: {
            prototype: {
                is_daytime: function() { ... }
            }
        }
    },
})
</code></pre>
<pre><code class="language-javascript">function build_daytime_greeter_class(deps) {
    const {
        HasTime,
        HasError,
        InGreeter,
    } = deps

    const { Time } = HasTime
    const { Error } = HasError

    return Class {
        constructor(in_greeter) {
            this.in_greeter = in_greeter
        }

        greet(context, person_id) {
            const now = HasTime.prototype.now.call(context)

            if Time.prototype.is_daytime.call(now) {
                return InGreeter.prototype.greet.call(
                    this.in_greeter, context, person_id)
            } else {
                throw Error.from(
                    new ShopeClosedError({ time: now }))
            }
        }
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../beginner/04-greeter-component.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../intermediate/02-component-composition.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../beginner/04-greeter-component.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../intermediate/02-component-composition.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
