<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Component Composition - Context-Generic Programming Guide (DRAFT)</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Beginner Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../beginner/01-simple-greeter.html"><strong aria-hidden="true">2.1.</strong> Simple Greeter</a></li><li class="chapter-item expanded "><a href="../beginner/02-generic-context.html"><strong aria-hidden="true">2.2.</strong> Generic Context</a></li><li class="chapter-item expanded "><a href="../beginner/03-context-implementation.html"><strong aria-hidden="true">2.3.</strong> Context Implementation</a></li><li class="chapter-item expanded "><a href="../beginner/04-greeter-component.html"><strong aria-hidden="true">2.4.</strong> Greeter Component</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Intermediate Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intermediate/01-daytime-greeter.html"><strong aria-hidden="true">3.1.</strong> Daytime Greeter</a></li><li class="chapter-item expanded "><a href="../intermediate/02-component-composition.html" class="active"><strong aria-hidden="true">3.2.</strong> Component Composition</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Advanced Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/01-person-querier.html"><strong aria-hidden="true">4.1.</strong> Person Querier</a></li><li class="chapter-item expanded "><a href="../advanced/02-querier-consumer.html"><strong aria-hidden="true">4.2.</strong> Querier Consumer</a></li><li class="chapter-item expanded "><a href="../advanced/03-store-impl.html"><strong aria-hidden="true">4.3.</strong> Store Implementation</a></li><li class="chapter-item expanded "><a href="../advanced/04-caching-querier.html"><strong aria-hidden="true">4.4.</strong> Caching Querier</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Context-Generic Programming Guide (DRAFT)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="component-composition"><a class="header" href="#component-composition">Component Composition</a></h1>
<p>Now that we have both <code>SimpleGreeter</code> and <code>DaytimeGreeter</code> implemented, we
can look at how we can define a full application context that satisfies the
constraints of both greeters. To better structure our application, we also
separate out different parts of the code into separate modules.</p>
<p>First, we put all the abstract traits into a <code>traits</code> module:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    mod traits {
        pub trait NamedPerson {
            fn name(&amp;self) -&gt; &amp;str;
        }

        pub trait SimpleTime {
            fn is_daytime(&amp;self) -&gt; bool;
        }

        pub trait HasError {
            type Error;
        }

        pub trait PersonContext {
            type PersonId;
            type Person: NamedPerson;
        }

        pub trait HasTime {
            type Time;

            fn now(&amp;self) -&gt; Self::Time;
        }
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This module does not contain any concrete type definitions, and thus has minimal
dependencies on external crates.</p>
<p>In practice, the trait definitions can be placed in different sub-modules so
that we can have more fine grained control over which traits a component depends
on.</p>
<p>Next, we define <code>SimpleGreeter</code> and <code>DaytimeGreeter</code> in separate modules.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    mod traits {
        // ...
<span class="boring">        pub trait NamedPerson {
</span><span class="boring">            fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait SimpleTime {
</span><span class="boring">            fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasError {
</span><span class="boring">            type Error;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonContext {
</span><span class="boring">            type PersonId;
</span><span class="boring">            type Person: NamedPerson;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasTime {
</span><span class="boring">            type Time;
</span><span class="boring">
</span><span class="boring">            fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">                -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait Greeter&lt;Context&gt;
</span><span class="boring">        where
</span><span class="boring">            Context: PersonContext + HasError,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">        }
</span>    }

    mod simple_greeter {
        use super::traits::{Greeter, NamedPerson, PersonQuerier};

        pub struct SimpleGreeter;

        impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
        where
            Context: PersonQuerier,
        {
            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
                -&gt; Result&lt;(), Context::Error&gt;
            {
                let person = context.query_person(person_id)?;
                println!(&quot;Hello, {}&quot;, person.name());
                Ok(())
            }
        }
    }

    mod daytime_greeter {
        use super::traits::{
            Greeter, HasError, PersonContext,
            HasTime, SimpleTime,
        };

        pub struct DaytimeGreeter&lt;InGreeter&gt;(pub InGreeter);

        pub struct ShopClosedError&lt;Time&gt; { time: Time }

        impl&lt;Context, InGreeter, Time, Error, PersonId&gt;
            Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
        where
            InGreeter: Greeter&lt;Context&gt;,
            Context: HasError&lt;Error=Error&gt;,
            Context: PersonContext&lt;PersonId=PersonId&gt;,
            Context: HasTime&lt;Time=Time&gt;,
            Time: SimpleTime,
            Error: From&lt;ShopClosedError&lt;Time&gt;&gt;,
        {
            fn greet(&amp;self, context: &amp;Context, person_id: &amp;PersonId)
                -&gt; Result&lt;(), Error&gt;
            {
                let now = context.now();
                if now.is_daytime() {
                    self.0.greet(context, person_id)
                } else {
                    Err(ShopClosedError { time: now }.into())
                }
            }
        }
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The two greeter components do not depend on each other, but they all depend
on the <code>traits</code> crate to make use of the abstract definitions. Since these
components do not depend on other crates, they are also <em>abstract</em> components
that can be instantiated with <em>any</em> context types that satisfy the trait
bounds.</p>
<p>Next, we define our concrete <code>AppContext</code> struct that implements all
context traits:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    mod traits {
        // ...
<span class="boring">        pub trait NamedPerson {
</span><span class="boring">            fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait SimpleTime {
</span><span class="boring">            fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasError {
</span><span class="boring">            type Error;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonContext {
</span><span class="boring">            type PersonId;
</span><span class="boring">            type Person: NamedPerson;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasTime {
</span><span class="boring">            type Time;
</span><span class="boring">
</span><span class="boring">            fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">                -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait Greeter&lt;Context&gt;
</span><span class="boring">        where
</span><span class="boring">            Context: PersonContext + HasError,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">        }
</span>    }

    mod simple_greeter {
        // ...
    }

    mod daytime_greeter {
        pub struct ShopClosedError&lt;Time&gt; { time: Time }
        // ...
    }

    mod context {
        use super::traits::*;
        use super::daytime_greeter::ShopClosedError;

        #[derive(Copy, Clone, PartialEq, Eq)]
        pub enum DummyTime {
            DayTime,
            NightTime,
        }

        pub struct BasicPerson {
            name: String,
        }

        pub struct AppContext {
            database: Database,
            time: DummyTime,
        }

        // Database stubs
        struct Database;
        struct DbError;

        pub enum AppError {
            Database(DbError),
            ShopClosed(ShopClosedError&lt;DummyTime&gt;),
            // ...
        }

        impl HasError for AppContext {
            type Error = AppError;
        }

        impl PersonContext for AppContext {
            type PersonId = String;
            type Person = BasicPerson;
        }

        impl HasTime for AppContext {
            type Time = DummyTime;

            fn now(&amp;self) -&gt; DummyTime {
                self.time
            }
        }

        impl PersonQuerier for AppContext {
            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
                -&gt; Result&lt;Self::Person, Self::Error&gt;
            {
                unimplemented!() // database stub
            }
        }

        impl NamedPerson for BasicPerson {
            fn name(&amp;self) -&gt; &amp;str {
                &amp;self.name
            }
        }

        impl SimpleTime for DummyTime {
            fn is_daytime(&amp;self) -&gt; bool {
                self == &amp;DummyTime::DayTime
            }
        }

        impl From&lt;ShopClosedError&lt;DummyTime&gt;&gt; for AppError {
            fn from(err: ShopClosedError&lt;DummyTime&gt;) -&gt; Self {
                Self::ShopClosed(err)
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Compared to before, we define a <code>DummyTime</code> struct that
mocks the current time with either day time or night time. We then
implement <code>HasTime</code> for <code>AppContext</code>, with <code>DummyTime</code> being the
<code>Time</code> type. We also add <code>ShopClosedError&lt;DummyTime&gt;</code> as a variant to
<code>AppError</code> and define a <code>From</code> instance for it.</p>
<p>As we can see in this exercise, by having all types used by the greeter
components as abstract types, it becomes very easy to mock up dependencies
such as time functionality without having to commit to a specific time library.
The explicit dependencies also help us better understand what features are
really needed from the concrete types. If we know that our application only needs
the <code>SimpleTime</code> trait, then there are more options out there that we can
try out and we can easily swap between them.</p>
<p>It is also worth noting that it doesn't matter whether the concrete types
<code>AppContext</code> and <code>BasicPerson</code> have private or public fields.
Since the components do not have access to the concrete types, all concrete
fields are essentially private and can only be exposed via trait methods.</p>
<p>Finally, we define an <code>instances</code> module to encapsulate the witness of
satisfying all dependencies required from <code>AppContext</code> to implement
the <code>Greeter</code> components:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    mod traits {
        // ...
<span class="boring">        pub trait NamedPerson {
</span><span class="boring">            fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait SimpleTime {
</span><span class="boring">            fn is_daytime(&amp;self) -&gt; bool;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasError {
</span><span class="boring">            type Error;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonContext {
</span><span class="boring">            type PersonId;
</span><span class="boring">            type Person: NamedPerson;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait HasTime {
</span><span class="boring">            type Time;
</span><span class="boring">
</span><span class="boring">            fn now(&amp;self) -&gt; Self::Time;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">                -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub trait Greeter&lt;Context&gt;
</span><span class="boring">        where
</span><span class="boring">            Context: PersonContext + HasError,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">        }
</span>    }

    mod simple_greeter {
        // ...
<span class="boring">        use super::traits::{Greeter, NamedPerson, PersonQuerier};
</span><span class="boring">
</span><span class="boring">        pub struct SimpleGreeter;
</span><span class="boring">
</span><span class="boring">        impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
</span><span class="boring">        where
</span><span class="boring">            Context: PersonQuerier,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Context::Error&gt;
</span><span class="boring">            {
</span><span class="boring">                let person = context.query_person(person_id)?;
</span><span class="boring">                println!(&quot;Hello, {}&quot;, person.name());
</span><span class="boring">                Ok(())
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }

    mod daytime_greeter {
        // ...
<span class="boring">        use super::traits::{
</span><span class="boring">            Greeter, HasError, PersonContext,
</span><span class="boring">            HasTime, SimpleTime,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        pub struct DaytimeGreeter&lt;InGreeter&gt;(pub InGreeter);
</span><span class="boring">
</span><span class="boring">        pub struct ShopClosedError&lt;Time&gt; { time: Time }
</span><span class="boring">
</span><span class="boring">        impl&lt;Context, InGreeter, Time, Error, PersonId&gt;
</span><span class="boring">            Greeter&lt;Context&gt; for DaytimeGreeter&lt;InGreeter&gt;
</span><span class="boring">        where
</span><span class="boring">            InGreeter: Greeter&lt;Context&gt;,
</span><span class="boring">            Context: HasError&lt;Error=Error&gt;,
</span><span class="boring">            Context: PersonContext&lt;PersonId=PersonId&gt;,
</span><span class="boring">            Context: HasTime&lt;Time=Time&gt;,
</span><span class="boring">            Time: SimpleTime,
</span><span class="boring">            Error: From&lt;ShopClosedError&lt;Time&gt;&gt;,
</span><span class="boring">        {
</span><span class="boring">            fn greet(&amp;self, context: &amp;Context, person_id: &amp;PersonId)
</span><span class="boring">                -&gt; Result&lt;(), Error&gt;
</span><span class="boring">            {
</span><span class="boring">                let now = context.now();
</span><span class="boring">                if now.is_daytime() {
</span><span class="boring">                    self.0.greet(context, person_id)
</span><span class="boring">                } else {
</span><span class="boring">                    Err(ShopClosedError { time: now }.into())
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }

    mod context {
        // ...
<span class="boring">        use super::traits::*;
</span><span class="boring">        use super::daytime_greeter::ShopClosedError;
</span><span class="boring">
</span><span class="boring">        #[derive(Copy, Clone, PartialEq, Eq)]
</span><span class="boring">        pub enum DummyTime {
</span><span class="boring">            DayTime,
</span><span class="boring">            NightTime,
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub struct BasicPerson {
</span><span class="boring">            name: String,
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        pub struct AppContext {
</span><span class="boring">            database: Database,
</span><span class="boring">            time: DummyTime,
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Database stubs
</span><span class="boring">        struct Database;
</span><span class="boring">        struct DbError;
</span><span class="boring">
</span><span class="boring">        pub enum AppError {
</span><span class="boring">            Database(DbError),
</span><span class="boring">            ShopClosed(ShopClosedError&lt;DummyTime&gt;),
</span><span class="boring">            // ...
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl HasError for AppContext {
</span><span class="boring">            type Error = AppError;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl PersonContext for AppContext {
</span><span class="boring">            type PersonId = String;
</span><span class="boring">            type Person = BasicPerson;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl HasTime for AppContext {
</span><span class="boring">            type Time = DummyTime;
</span><span class="boring">
</span><span class="boring">            fn now(&amp;self) -&gt; DummyTime {
</span><span class="boring">                self.time
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl PersonQuerier for AppContext {
</span><span class="boring">            fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">                -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">            {
</span><span class="boring">                unimplemented!() // database stub
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl NamedPerson for BasicPerson {
</span><span class="boring">            fn name(&amp;self) -&gt; &amp;str {
</span><span class="boring">                &amp;self.name
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl SimpleTime for DummyTime {
</span><span class="boring">            fn is_daytime(&amp;self) -&gt; bool {
</span><span class="boring">                self == &amp;DummyTime::DayTime
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl From&lt;ShopClosedError&lt;DummyTime&gt;&gt; for AppError {
</span><span class="boring">            fn from(err: ShopClosedError&lt;DummyTime&gt;) -&gt; Self {
</span><span class="boring">                Self::ShopClosed(err)
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }

    mod instances {
        use super::traits::Greeter;
        use super::context::AppContext;
        use super::simple_greeter::SimpleGreeter;
        use super::daytime_greeter::DaytimeGreeter;

        pub fn base_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
            SimpleGreeter
        }

        pub fn app_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
            DaytimeGreeter(base_greeter())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We first have a <code>base_greeter</code> function which witnesses that <code>SimpleGreeter</code>
implements <code>Greeter&lt;AppContext&gt;</code>. We then define an <code>app_greeter</code> function
which witnesses that <code>DaytimeGreeter&lt;SimpleGreeter&gt;</code> <em>also</em> implements
<code>Greeter&lt;AppContext&gt;</code>.</p>
<p>Notice that in the <code>app_greeter</code> body, we construct the greeter with
<code>DaytimeGreeter(base_greeter())</code> instead of <code>DaytimeGreeter(SimpleGreeter)</code>.
In theory, both expressions are valid and have the same effect, but calling
<code>base_greeter</code> inside <code>app_greeter</code> implies that <code>app_greeter</code> does not care
what the concrete type of <code>base_greeter</code> is; all that matters is that it
implements <code>Greeter&lt;AppContext&gt;</code>.</p>
<p>Having separate witness functions can also help us debug any errors that arise
in dependencies much more easily. Let's say that we forgot to implement
<code>PersonQuerier</code> for <code>AppContext</code> such that the dependency for
<code>SimpleGreeter</code> would not be satisfied; we would get a type error in
<code>base_greeter</code>. However, no errors would crop up in <code>app_greeter</code>,
because it doesn't care that base greeter implements <code>SimpleGreeter</code>.</p>
<p>If we were to write the complex expression in one go, like
<code>DaytimeGreeter(SimpleGreeter)</code>, it would be less clear which part of the
expression caused the type error. Things would get worse if we introduced more
complex component composition. Therefore, it is always a good practice to
define the component instantiation in multiple smaller functions so that
it is clear to the reader whether the dependencies are being resolved
correctly.</p>
<h2 id="component-graph-visualization"><a class="header" href="#component-graph-visualization">Component Graph Visualization</a></h2>
<a href="https://app.excalidraw.com/l/4XqkU6POmGI/2PCintQJN3m" target="_blank">
    <div style="pointer-events: none;">
        <embed src="../images/daytime-greeter-graph.svg"
            width="100%"
        />
    </div>
</a>
<h2 id="reader-monad"><a class="header" href="#reader-monad">Reader Monad</a></h2>
<p>Readers coming from a functional programming background might notice
that the context pattern looks similar to the reader monad pattern. This is
correct, as we are defining a global <code>Context</code> type and passing it around as a
function argument to all code that requires the context. Additionally, we make
use of the trait (typeclass) system in Rust for compile-time dependency
injection, and the same pattern can be applied for the context type used in
reader monads.</p>
<p>For Rust readers, the main difference of the pattern described here with the
reader monad is that we are passing the context value as an explicit argument
without making use of any monadic constructs. Doing it this way is slightly more
verbose, but the upside is that we still get to enjoy much of the benefits of
the reader monad pattern without requiring Rust programmers to learn what a
monad really is (though if you're comfortable with using <code>Result</code> and <code>Option</code>,
you've already been making use of monads).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../intermediate/01-daytime-greeter.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../advanced/01-person-querier.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../intermediate/01-daytime-greeter.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../advanced/01-person-querier.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
