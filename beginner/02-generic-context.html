<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generic Context - IBC Relayer Framework Guide (DRAFT)</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Beginner Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../beginner/01-simple-greeter.html"><strong aria-hidden="true">2.1.</strong> Simple Greeter</a></li><li class="chapter-item expanded "><a href="../beginner/02-generic-context.html" class="active"><strong aria-hidden="true">2.2.</strong> Generic Context</a></li><li class="chapter-item expanded "><a href="../beginner/03-context-implementation.html"><strong aria-hidden="true">2.3.</strong> Context Implementation</a></li><li class="chapter-item expanded "><a href="../beginner/04-greeter-component.html"><strong aria-hidden="true">2.4.</strong> Greeter Component</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Intermediate Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intermediate/01-daytime-greeter.html"><strong aria-hidden="true">3.1.</strong> Daytime Greeter</a></li><li class="chapter-item expanded "><a href="../intermediate/02-component-composition.html"><strong aria-hidden="true">3.2.</strong> Component Composition</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Advanced Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/01-person-querier.html"><strong aria-hidden="true">4.1.</strong> Person Querier</a></li><li class="chapter-item expanded "><a href="../advanced/02-querier-consumer.html"><strong aria-hidden="true">4.2.</strong> Querier Consumer</a></li><li class="chapter-item expanded "><a href="../advanced/03-store-impl.html"><strong aria-hidden="true">4.3.</strong> Store Implementation</a></li><li class="chapter-item expanded "><a href="../advanced/04-caching-querier.html"><strong aria-hidden="true">4.4.</strong> Caching Querier</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">IBC Relayer Framework Guide (DRAFT)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="generic-context"><a class="header" href="#generic-context">Generic Context</a></h1>
<p>There are ways that we can make our <code>greet</code> function in Rust works more flexibly
similar to its dynamic-typed counterparty. First, we define a concrete <code>Context</code>
type as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Database { /* ... */}
</span><span class="boring">struct DbError { /* ... */}
</span><span class="boring">impl Database {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, DbError&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>struct Context {
    database: Database,
    // ...
}

fn greet(context: &amp;Context, person_id: &amp;PersonId) -&gt; Result&lt;(), DbError&gt; {
    let person = context.database.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>At this stage, we have a concrete <code>Context</code> struct that contains the database
handle as well as other environment parameters that we may need. However,
<code>Context</code> is still concrete, so it is difficult to reuse the <code>greet</code> function
in a different context. So let's make the <code>Context</code> generic instead:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Database { /* ... */}
</span><span class="boring">struct DbError { /* ... */}
</span><span class="boring">
</span><span class="boring">impl Database {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, DbError&gt; {
</span><span class="boring">         unimplemented!() // stub
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">
</span>trait ContextWithDatabase {
    fn database(&amp;self) -&gt; &amp;Database;
}

fn greet&lt;Context&gt;(context: &amp;Context, person_id: &amp;PersonId) -&gt; Result&lt;(), DbError&gt;
where
    Context: ContextWithDatabase,
{
    let person = context.database().query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>In our first attempt, we turn <code>Context</code> into a generic type parameter.
With that, the concrete details of the context are lost, and we no longer
know how to access the fields such as the database. But we can recover that
by defining a <code>ContextWithDatabase</code> trait, which provides read-only
access to extract a reference to <code>Database</code> from the context.</p>
<p>With that, we are able to make <code>greet</code> work with any context type as
long as it contains a field for <code>Database</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Database { /* ... */}
</span><span class="boring">
</span><span class="boring">trait ContextWithDatabase {
</span><span class="boring">     fn database(&amp;self) -&gt; &amp;Database;
</span><span class="boring">}
</span><span class="boring">
</span>struct AppContext {
    database: Database
}

impl ContextWithDatabase for AppContext {
    fn database(&amp;self) -&gt; &amp;Database {
        &amp;self.database
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, since the <code>Database</code> type is concrete, it is challenging if we
want to run <code>greet</code> with an environment without a database, such as
an in-memory key-value store, cache store, or a blockchain. What we can do
instead is to define methods such that we can query for a person's details
directly from the context:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span>struct Error { /* ... */}

trait PersonQuerier {
    fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, Error&gt;;
}

fn greet&lt;Context&gt;(context: &amp;Context, person_id: &amp;PersonId)
    -&gt; Result&lt;(), Error&gt;
where
    Context: PersonQuerier,
{
    let person = context.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>We define a <code>PersonQuerier</code> trait that exposes a method for querying for a
person's details directly from the context. With that, we can have our <code>greet</code>
function work with any context type that knows how to query for person details,
regardless of whether it is implemented as a database query.</p>
<h2 id="context-with-error"><a class="header" href="#context-with-error">Context with Error</a></h2>
<p>One thing to note however is that the <code>Error</code> type in <code>PersonQuerier</code>
is concrete. With that, it would be problematic if we want to define new contexts
that have different query methods but also return different errors. While it
is possible to define a dynamic error type such as <code>Box&lt;dyn Error&gt;</code>, such type
erasure would mean that we lose information about what kinds of errors can happen
when we try to query for <code>Person</code> details.</p>
<p>We can instead make the error type <em>generic</em>. But instead of using it as a
generic parameter for <code>greet</code>, we can define it as an <em>associated type</em> for
the generic type <code>Context</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span>trait HasError {
    type Error;
}

trait PersonQuerier: HasError {
    fn query_person(&amp;self, person_id: &amp;PersonId) -&gt; Result&lt;Person, Self::Error&gt;;
}

fn greet&lt;Context&gt;(context: &amp;Context, person_id: &amp;PersonId) -&gt; Result&lt;(), Context::Error&gt;
where
    Context: PersonQuerier,
{
    let person = context.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>We define a new <code>HasError</code> trait with only one thing, which is the <code>Error</code>
associated type. Aside from that, there is nothing known about the <code>Error</code>
type, but that is ok as we will see later on. The trait <code>PersonQuerier</code>
then has <code>HasError</code> as its supertrait, esentially allowing it to access
the associated type as <code>Self::Error</code> in the return type of <code>query_person</code>.</p>
<p>We define the <code>Error</code> associated type in a separate <code>HasError</code> trait,
instead of directly in the <code>PersonQuerier</code> trait. As we will see later,
this is essential to allow multiple context traits to access the same
<code>Error</code> type.</p>
<p>In the <code>greet</code> function, we require the generic <code>Context</code> type to
implement <code>PersonQuerier</code>. But since <code>HasError</code> is a supertrait of
<code>PersonQuerier</code>, we would also able to access the error type as
<code>Context::Error</code>.</p>
<h2 id="explicit-associated-type-binding"><a class="header" href="#explicit-associated-type-binding">Explicit Associated Type Binding</a></h2>
<p>As we can see, by having generic type parameters as associated types in the
traits that <code>Context</code> implements, we are able to keep just one generic type
parameter in the <code>greet</code> function.</p>
<p>However, it is still possible for us to explicitly pull out <code>Error</code> as a generic
type parameter and bind to the <code>Error</code> associated type as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PersonId(String);
</span><span class="boring">struct Person {
</span><span class="boring">     id: PersonId,
</span><span class="boring">     name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier: HasError {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;PersonId) -&gt;    Result&lt;Person, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>fn greet&lt;Context, Error&gt;(context: &amp;Context, person_id: &amp;PersonId)
    -&gt; Result&lt;(), Error&gt;
where
    Context: PersonQuerier&lt;Error=Error&gt;,
{
    let person = context.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>By specifying the trait bound <code>Context: PersonQuerier&lt;Error=Error&gt;</code>,
we state that the <code>greet</code> function works with any generic type <code>Error</code>,
provided that <code>Context::Error</code> is the same as <code>Error</code>. With the explicit
binding, we are able to have <code>greet</code> return <code>Result&lt;(), Error&gt;</code> instead of
<code>Result&lt;(), Context::Error&gt;</code>.</p>
<p>There are sometimes benefits when we bind the associated types to an explicit
generic type parameter. For one, the inferred type shown in IDEs like
Rust Analyzer would be simpler, as they are shown as <code>Error</code> instead of
the fully qualified syntax <code>&lt;Context as HasError&gt;::Error</code>.
As we will see later, explicit type parameters also help us by providing a
way to specify the additional trait bounds of the associated types.</p>
<p>Aside from that, it is up to the programmer to decide whether to bind
the associated types to explicit type parameters. The key thing to understand
here is that the explicit bindings are optional, and we can choose to
omit such parameters whenever it is appropriate.</p>
<h2 id="generic-person"><a class="header" href="#generic-person">Generic Person</a></h2>
<p>Right now, our <code>Error</code> type has become generic, but our <code>Person</code> type is
still concrete. We may also want to make the <code>Person</code> type generic in a
similar way, so that the <code>greet</code> function can work with any other
person types.</p>
<p>This may be essential for reasons such as performance. For instance,
depending on where <code>greet</code> is called, it may be desirable to load
all details about a person from the database so that it can be
cached, or conversely, it might be desirable to load minimal details in order to
save bandwidth.</p>
<p>From the perspective of <code>greet</code>, it does not matter what fields a <code>Person</code>
type has, as long as it can extract the name of the person as a string.
So we can generalize the <code>Person</code> type as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait NamedPerson {
    fn name(&amp;self) -&gt; &amp;str;
}

trait HasError {
    type Error;
}

trait PersonContext {
    type PersonId;
    type Person: NamedPerson;
}

trait PersonQuerier: PersonContext + HasError {
    fn query_person(
        &amp;self,
        person_id: &amp;Self::PersonId,
    ) -&gt; Result&lt;Self::Person, Self::Error&gt;;
}

fn greet&lt;Context&gt;(
    context: &amp;Context,
    person_id: &amp;Context::PersonId,
) -&gt; Result&lt;(), Context::Error&gt;
where
    Context: PersonQuerier,
{
    let person = context.query_person(person_id)?;
    println!(&quot;Hello, {}&quot;, person.name());
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>We first define a <code>NamedPerson</code> trait, with a <code>name</code> method to extract a string
out from the person. We also define a <code>PersonContext</code> trait that has two
associated types: <code>PersonId</code> and <code>Person</code>. The <code>PersonId</code> type is completely
generic, as we don't care whether it is a string, an integer, or a UUID.
The associated type <code>Person</code> is also generic, but we also add a trait bound
that the type must implement <code>NamedPerson</code>.</p>
<p>The <code>PersonQuerier</code> is now defined with <code>PersonContext</code> as another of its
supertraits. With that, the <code>query_person</code> method becomes completely abstract.
A generic consumer would only know that, given an abstract type
<code>Context::PersonId</code>, it can query the <code>Context</code> and either get back an abstract
type <code>Context::Person</code> that implements <code>NamedPerson</code>, or get back an abstract
error <code>Context::Error</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../beginner/01-simple-greeter.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../beginner/03-context-implementation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../beginner/01-simple-greeter.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../beginner/03-context-implementation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
