<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Greeter Component - Context-Generic Programming Guide (DRAFT)</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Beginner Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../beginner/01-simple-greeter.html"><strong aria-hidden="true">2.1.</strong> Simple Greeter</a></li><li class="chapter-item expanded "><a href="../beginner/02-generic-context.html"><strong aria-hidden="true">2.2.</strong> Generic Context</a></li><li class="chapter-item expanded "><a href="../beginner/03-context-implementation.html"><strong aria-hidden="true">2.3.</strong> Context Implementation</a></li><li class="chapter-item expanded "><a href="../beginner/04-greeter-component.html" class="active"><strong aria-hidden="true">2.4.</strong> Greeter Component</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Intermediate Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intermediate/01-daytime-greeter.html"><strong aria-hidden="true">3.1.</strong> Daytime Greeter</a></li><li class="chapter-item expanded "><a href="../intermediate/02-component-composition.html"><strong aria-hidden="true">3.2.</strong> Component Composition</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Advanced Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/01-person-querier.html"><strong aria-hidden="true">4.1.</strong> Person Querier</a></li><li class="chapter-item expanded "><a href="../advanced/02-querier-consumer.html"><strong aria-hidden="true">4.2.</strong> Querier Consumer</a></li><li class="chapter-item expanded "><a href="../advanced/03-store-impl.html"><strong aria-hidden="true">4.3.</strong> Store Implementation</a></li><li class="chapter-item expanded "><a href="../advanced/04-caching-querier.html"><strong aria-hidden="true">4.4.</strong> Caching Querier</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Context-Generic Programming Guide (DRAFT)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="greeter-component"><a class="header" href="#greeter-component">Greeter Component</a></h1>
<p>The <code>greet</code> function that we have defined at this point can now work with
any context type that implements the required traits. In practice, we may
also want to implement different versions of the <code>greet</code> function so that
they can be consumed generically by other components.</p>
<p>With the generic context design, we define a <code>Greeter</code> interface that
is parameterized by a generic context, and can be used by any other
components that also share the same context. This can be defined as
follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait Greeter&lt;Context&gt;
where
    Context: PersonContext + HasError,
{
    fn greet(
        &amp;self,
        context: &amp;Context,
        person_id: &amp;Context::PersonId,
    ) -&gt; Result&lt;(), Context::Error&gt;;
}

struct SimpleGreeter;

impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
where
    Context: PersonQuerier,
{
    fn greet(
        &amp;self,
        context: &amp;Context,
        person_id: &amp;Context::PersonId,
    ) -&gt; Result&lt;(), Context::Error&gt;
    {
        let person = context.query_person(person_id)?;
        println!(&quot;Hello, {}&quot;, person.name());
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Greeter</code> trait is defined to be parameterized by a generic <code>Context</code> type,
which is required to implement both <code>PersonContext</code> and <code>HasError</code>.
The <code>greet</code> method is then defined without generic parameters, as these have been
captured in the trait definition. We then define an empty struct <code>SimpleGreeter</code>,
which is there only to implement the <code>Greeter</code> trait for any <code>Context</code> type
that implements <code>PersonQuerier</code>.</p>
<p>It is worth noticing here that in the main <code>Greeter</code> trait definition,
the <code>Context</code> type, is only required to implement <code>PersonContext</code> and
<code>HasError</code>, but there is no mention of the <code>PersonQuerier</code>
trait bound. On the other hand, the concrete <code>Greeter</code> implementation
for <code>SimpleGreeter</code> can require the additional trait bound
<code>Context: PersonQuerier</code> in its <code>impl</code> definition.</p>
<p>This demonstrates the benefits of separating the <code>PersonQuerier</code>
from the <code>PersonContext</code> trait: From the perspective of a consumer
that uses the <code>Greeter</code> component, it does not need to know whether
the generic context type implements <code>PersonQuerier</code>. This means
that from the trait bounds alone, we can tell whether a piece of code
can call <code>query_person</code> directly, or whether it can only call the
<code>greet</code> method to greet a person without knowing how the greeter determined
the person's name.</p>
<h2 id="greeter-instance"><a class="header" href="#greeter-instance">Greeter Instance</a></h2>
<p>In the previous chapter, we defined <code>AppContext</code> as a concrete implementation
for the context traits <code>HasError</code>, <code>PersonContext</code>, and <code>PersonQuerier</code>.
Based on the earlier definition of <code>SimpleGreeter</code> and its <code>Greeter</code>
implementation, we can deduce that <code>SimpleGreeter</code> should implement
<code>Greeter&lt;AppContext&gt;</code>.</p>
<p>But how can we ensure that we implemented <code>AppContext</code> correctly to be used by
<code>SimpleGreeter</code>? If we forgot to implement any dependency that is required by
<code>SimpleGreeter</code>, such as <code>PersonQuerier</code>, we would get a compile-time error
when trying to use <code>SimpleGreeter</code> as <code>Greeter&lt;AppContext&gt;</code>. Worse, if we try
to use <code>SimpleGreeter</code> within another generic component, the error messages
may become too incomprehensible to find out what went wrong.</p>
<p>In test-driven development, it is common practice that we would write <em>tests</em>
that check that our code satisfies certain requirements and constraints.
Following the same principle, we would want to write tests that check that
<code>SimpleGreeter</code> does implements <code>Greeter&lt;AppContext&gt;</code>. But instead of writing
<em>dynamic tests</em> that checks for the program behavior at runtime, we can write
<em>static tests</em> that checks that the program requirements are satisfied at
<em>compile time</em>.</p>
<p>Our test would be implemented as an <code>app_greeter</code> function which checks at
<em>compile time</em> that <code>SimpleGreeter</code> implements <code>Greeter&lt;AppContext&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait HasError {
</span><span class="boring">     type Error;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonContext {
</span><span class="boring">     type PersonId;
</span><span class="boring">     type Person: NamedPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait PersonQuerier: PersonContext + HasError {
</span><span class="boring">     fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">         -&gt; Result&lt;Self::Person, Self::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Greeter&lt;Context&gt;
</span><span class="boring">where
</span><span class="boring">     Context: PersonContext + HasError,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleGreeter;
</span><span class="boring">
</span><span class="boring">impl&lt;Context&gt; Greeter&lt;Context&gt; for SimpleGreeter
</span><span class="boring">where
</span><span class="boring">     Context: PersonQuerier,
</span><span class="boring">{
</span><span class="boring">     fn greet(&amp;self, context: &amp;Context, person_id: &amp;Context::PersonId)
</span><span class="boring">         -&gt; Result&lt;(), Context::Error&gt;
</span><span class="boring">     {
</span><span class="boring">         let person = context.query_person(person_id)?;
</span><span class="boring">         println!(&quot;Hello, {}&quot;, person.name());
</span><span class="boring">         Ok(())
</span><span class="boring">     }
</span><span class="boring">}
</span><span class="boring">struct BasicPerson {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl NamedPerson for BasicPerson {
</span><span class="boring">    fn name(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct AppContext {
</span><span class="boring">    database: Database,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Database stubs
</span><span class="boring">struct Database;
</span><span class="boring">struct DbError;
</span><span class="boring">
</span><span class="boring">enum AppError {
</span><span class="boring">    Database(DbError),
</span><span class="boring">    // ...
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl HasError for AppContext {
</span><span class="boring">    type Error = AppError;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PersonContext for AppContext {
</span><span class="boring">    type PersonId = String;
</span><span class="boring">    type Person = BasicPerson;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PersonQuerier for AppContext {
</span><span class="boring">    fn query_person(&amp;self, person_id: &amp;Self::PersonId)
</span><span class="boring">        -&gt; Result&lt;Self::Person, Self::Error&gt;
</span><span class="boring">    {
</span><span class="boring">        unimplemented!() // database stub
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn app_greeter() -&gt; impl Greeter&lt;AppContext&gt; {
    SimpleGreeter
}
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>app_greeter</code> function accepts nothing and returns <code>impl Greeter&lt;AppContext&gt;</code>.
This indicates that the function can return a value with an <em>existential type</em>
that implements <code>Greeter&lt;AppContext&gt;</code>. Inside the function body, we simply
return a <code>SimpleGreeter</code> value. From the surface, it may look like this
is effectively the same as the function with signature
<code>fn app_greeter() -&gt; SimpleGreeter</code>. But by returning <code>impl Greeter&lt;AppContext&gt;</code>,
we force the Rust compiler to check here that <code>SimpleGreeter</code> must
implement <code>Greeter&lt;AppContext&gt;</code>.</p>
<p>Having <code>app_greeter</code> compiled successfully is sufficient to prove that
<code>SimpleGreeter</code> can <em>always</em> be used as a <code>Greeter&lt;AppContext&gt;</code>. Hence, we can
say that <code>app_greeter</code> is a <em>proof</em> that <code>SimpleGreeter: Greeter&lt;AppContext&gt;</code>.</p>
<p>We call static tests like <code>app_greeter</code> as proofs, as it works similar to
writing mathematical proofs as programs in <em>dependent-typed programming</em>.
In this style of programming,the type-checking of a program alone is sufficient
to prove that a given requirement is <em>always</em> satisfied, without us having to
<em>execute</em> the program.
This is much more efficient as compared to dynamic checking, which can only
check for requirements at runtime and raise errors when the requirements
are not satisfied.</p>
<h2 id="compile-time-dependency-injection"><a class="header" href="#compile-time-dependency-injection">Compile-Time Dependency Injection</a></h2>
<p>The <code>app_greeter</code> function demonstrates a form of <em>dependency injection</em>
done at compile time. This is because for any code to use a type implementing
<code>Greeter&lt;Context&gt;</code>, they only need to know that <code>Context</code> implements
<code>HasError</code> and <code>PersonContext</code>. But to make <code>SimpleGreeter</code> implement
<code>Greeter&lt;Context&gt;</code>, it also needs <code>Context</code> to implement <code>PersonQuerier</code>.</p>
<p>When we return <code>SimpleGreeter</code> inside <code>app_greeter</code>, the Rust compiler
figures out that <code>SimpleGreeter</code> requires <code>AppContext</code> to implement
<code>PersonQuerier</code>. It would then try to automatically <em>resolve</em> the
dependency by searching for an implementation of <code>PersonQuerier</code>
for <code>AppContext</code>. Upon finding the implementation, Rust &quot;binds&quot; that
implementation with <code>SimpleGreeter</code> and returns it as an existential
type that implements <code>Greeter&lt;AppContext&gt;</code>. As a result,
we can treat the type returned from <code>app_greeter</code> as an abstract type,
and &quot;forget&quot; the fact that <code>AppContext</code> implements <code>PersonQuerier</code>.</p>
<p>This pattern of making use of Rust's trait system for dependency injection
efficiently solves the
<a href="https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/">context and capabilities problem</a>
in Rust. Without it, we would have to rely on more exotic language features
that are not available in Rust, or resort to manually passing dependencies
around by hand.</p>
<p>For example, we could perform manual binding for an implementation similar
to <code>SimpleGreeter</code> as a purely generic function as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait NamedPerson {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span>fn make_simpler_greeter&lt;Context, PersonId, Person, Error&gt;(
    query_person: impl Fn(&amp;Context, &amp;PersonId) -&gt; Result&lt;Person, Error&gt;,
) -&gt; impl Fn(&amp;Context, &amp;PersonId) -&gt; Result&lt;(), Error&gt;
where
    Person: NamedPerson,
{
    move | context, person_id | {
        let person = query_person(context, person_id)?;
        println!(&quot;Hello, {}&quot;, person.name());
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As we can see, the ad hoc function <code>make_simpler_greeter</code> that we defined is
much more verbose than the earlier trait-based implementation. We would
have to explicitly track 4 generic type parameters, and we would have to
manually pass in dependencies like <code>query_person</code> and return nested closures.</p>
<p>When we delegate the management of the context dependencies to Rust's trait
system, the Rust compiler handles the binding of dependencies automatically in
a manner similar to what is being done in the example above. The binding process
is not only automated, the code that the compiler generates is also much more
efficient. Because the binding is done at compile time, the Rust compiler is
able to perform many further optimizations, such as code inlining.</p>
<p>As we will see later, this process of automatic resolution can be applied to
<em>nested</em> dependencies. Thanks to how the trait system works, we can specify
complex dependencies for our components and have the Rust compiler figure out
how to stitch together the dependencies and construct the combined components
that we need.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../beginner/03-context-implementation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../intermediate/01-daytime-greeter.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../beginner/03-context-implementation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../intermediate/01-daytime-greeter.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
